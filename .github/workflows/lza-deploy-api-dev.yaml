name: Deploy LZA reserve-rec-api Dev

run-name: Deploying ${{ github.ref_name }} (API) to LZA dev environment

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-lza-reserve-rec-api
  cancel-in-progress: false

env:
  # Secrets
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_APP_CLIENT_NAME: ${{ secrets.AZURE_APP_CLIENT_NAME }}
  AZURE_PROVIDER_NAME: ${{ secrets.AZURE_PROVIDER_NAME }}
  AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  AZURE_CALLBACK_URLS: ${{ secrets.AZURE_CALLBACK_URLS }}
  AZURE_LOGOUT_URLS: ${{ secrets.AZURE_LOGOUT_URLS }}
  AZURE_ALLOWED_OAUTH_FLOWS: ${{ secrets.AZURE_ALLOWED_OAUTH_FLOWS }}
  AZURE_ISSUER_URL: ${{ vars.AZURE_ISSUER_URL }}
  DATA_REGISTER_API_KEY: ${{ secrets.DATA_REGISTER_API_KEY }}
  JWKS: ${{ secrets.JWKS }}
  KMS_KEY_ID: ${{ secrets.KMS_KEY_ID }}
  OPENSEARCH_ADMIN_PASSWORD: $${{ secrets.OPENSEARCH_ADMIN_PASSWORD }}
  COGNITO_DOMAIN: ${{ secrets.COGNITO_DOMAIN }}

  # Worldline
  MERCHANT_ID: ${{ secrets.MERCHANT_ID }}
  HASH_KEY: ${{ secrets.HASH_KEY }}
  WORLDLINE_WEBHOOK_SECRET: ${{ secrets.WORLDLINE_WEBHOOK_SECRET }}

  # Variables
  ALLOW_ORIGIN: ${{ vars.ALLOW_ORIGIN }}
  COGNITO_CALLBACK_URLS: ${{ vars.COGNITO_CALLBACK_URLS }}
  DATA_REGISTER_URL: ${{ vars.DATA_REGISTER_URL}}
  DOMAIN_ENDPOINT: ${{ vars.DOMAIN_ENDPOINT }}
  EBS_IOPS: ${{ vars.EBS_IOPS }}
  INSTANCE_COUNT: ${{ vars.INSTANCE_COUNT }}
  INSTANCE_TYPE: ${{ vars.INSTANCE_TYPE }}
  OPENSEARCH_MAIN_INDEX: $${{ vars.OPENSEARCH_MAIN_INDEX }}
  OPENSEARCH_DOMAIN_URL: $${{ vars.OPENSEARCH_DOMAIN_URL }}
  SAML_IDP_ENTITY_ID: $${{ vars.SAML_IDP_ENTITY_ID }}
  STACK_NAME: ${{ vars.STACK_NAME }}
  API_STAGE: ${{ vars.API_STAGE }}
  TABLE_NAME: ${{ vars.TABLE_NAME }}
  AUDIT_TABLE_NAME: ${{ vars.AUDIT_TABLE_NAME }}
  PUBSUB_TABLE_NAME: ${{ vars.PUBSUB_TABLE_NAME }}
  IS_OFFLINE: 'false'
  DYNAMODB_ENDPOINT_URL: ${{ vars.DYNAMODB_ENDPOINT_URL }}
  S3_BUCKET_GEOSPATIAL: ${{ vars.S3_BUCKET_GEOSPATIAL }}
  LOG_LEVEL: ${{ vars.LOG_LEVEL }}
  ENVIRONMENT: ${{ vars.ENVIRONMENT }}
  JWT_KEY_ID: ${{ vars.JWT_KEY_ID }}
  BCSC_KEY_ID: ${{ secrets.BCSC_KEY_ID }}

  # Public Cognito
  PUBLIC_USER_POOL_NAME: ${{ vars.PUBLIC_USER_POOL_NAME }}
  PUBLIC_USER_POOL_CLIENT_NAME: ${{ vars.PUBLIC_USER_POOL_CLIENT_NAME }}
  PUBLIC_COGNITO_CALLBACK_URLS: ${{ vars.PUBLIC_COGNITO_CALLBACK_URLS }}

  # Admin Cognito
  ADMIN_USER_POOL_NAME: ${{ vars.ADMIN_USER_POOL_NAME }}
  ADMIN_USER_POOL_CLIENT_NAME: ${{ vars.ADMIN_USER_POOL_CLIENT_NAME }}
  ADMIN_COGNITO_CALLBACK_URLS: ${{ vars.ADMIN_COGNITO_CALLBACK_URLS }}
  ADMIN_USER_POOL_ID: ${{ secrets.ADMIN_USER_POOL_ID }}
  ADMIN_CLIENT_ID: ${{ secrets.ADMIN_CLIENT_ID }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: lzadev
    strategy:
      max-parallel: 1
      matrix:
        node-version: [20.x]
    steps:
      ### Checkout GitHub Repo
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install AWS CDK
        run: |
          yarn
          yarn global add aws-cdk

      ### Assume AWS IAM Role
      - name: Get AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ vars.AWS_REGION }}

      ### Deploy Table Manager (one time setup)
      - name: Deploy Table Manager
        run: |
          echo "Deploying Table Manager infrastructure..."
          cdk deploy ReserveRecTableManager --app 'node bin/table-manager.js' --require-approval never || echo "Table Manager already exists"

      ### Check if this is a first deployment
      - name: Detect Deployment Type
        id: deployment-type
        env:
          STACK_NAME: ${{ vars.STACK_NAME }}
        run: |
          echo "Checking deployment type for stack: $STACK_NAME"
          
          # Check if the main stack exists
          STACK_EXISTS=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "NOT_EXISTS")
          
          # Check if Parameter Store entries exist
          PARAM_PATH="/reserve-rec/${STACK_NAME}/tables/main/arn"
          
          PARAM_EXISTS=$(aws ssm get-parameter --name "$PARAM_PATH" --query 'Parameter.Value' --output text 2>/dev/null || echo "NOT_EXISTS")
          
          echo "Stack exists: $STACK_EXISTS"
          echo "Parameters exist: $PARAM_EXISTS"
          
          if [ "$STACK_EXISTS" = "NOT_EXISTS" ] && [ "$PARAM_EXISTS" = "NOT_EXISTS" ]; then
            echo "DEPLOYMENT_TYPE=FIRST" >> $GITHUB_OUTPUT
            echo "This is a first deployment - will create tables via CDK"
          elif [ "$STACK_EXISTS" != "NOT_EXISTS" ] && [ "$PARAM_EXISTS" != "NOT_EXISTS" ]; then
            echo "DEPLOYMENT_TYPE=NORMAL" >> $GITHUB_OUTPUT
            echo "This is a normal deployment - will use Parameter Store"
          else
            echo "DEPLOYMENT_TYPE=ADOPTION" >> $GITHUB_OUTPUT
            echo "This is an adoption deployment - will register existing tables"
          fi

      ### Manage Tables (only if not first deployment)
      - name: Manage Tables
        if: steps.deployment-type.outputs.DEPLOYMENT_TYPE != 'FIRST'
        env:
          TABLE_NAME: ${{ vars.TABLE_NAME }}
          STACK_NAME: ${{ vars.STACK_NAME }}
        run: |
          echo "Registering tables for stack: $STACK_NAME"
          npm run quick-tables manage $STACK_NAME || echo "Table management failed - will proceed with table creation"

      ### CDK Synth
      - name: CDK Synth
        run: cdk synth

      ## CDK Deploy
      - name: CDK Deploy
        env:
          FORCE_CREATE_TABLES: ${{ steps.deployment-type.outputs.DEPLOYMENT_TYPE == 'FIRST' && 'true' || 'false' }}
        run: |
          echo "Deploying $STACK_NAME"
          echo "Deployment type: ${{ steps.deployment-type.outputs.DEPLOYMENT_TYPE }}"
          echo "Force create tables: $FORCE_CREATE_TABLES"
          cdk deploy $STACK_NAME --require-approval never --rollback --outputs-file cfn-outputs.json
          cat cfn-outputs.json

      ### Post-deployment: Register newly created tables (only for first deployments)
      - name: Register New Tables
        if: steps.deployment-type.outputs.DEPLOYMENT_TYPE == 'FIRST'
        env:
          TABLE_NAME: ${{ vars.TABLE_NAME }}
          STACK_NAME: ${{ vars.STACK_NAME }}
        run: |
          echo "Registering newly created tables for future deployments..."
          npm run quick-tables manage $STACK_NAME || echo "Post-deployment table registration failed"

      ## Update Config
      - name: Update Config
        env:
          TABLE_NAME: ${{ vars.TABLE_NAME }}
          STACK_NAME: ${{ vars.STACK_NAME }}
        run: |
          node lib/tools/cicd/updateConfig.js cfn-outputs.json lib/tools/cicd/valid_admin_attributes.json admin $STACK_NAME
          node lib/tools/cicd/updateConfig.js cfn-outputs.json lib/tools/cicd/valid_public_attributes.json public $STACK_NAME
