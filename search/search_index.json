{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"BC Parks Reservation System Documentation","text":""},{"location":"contexts/admin-user-journey-phases/","title":"Admin User Journey Phases","text":"<p>Phases of the admin user journey:</p> <ul> <li>Experience Configuration: Admins define the spatial, experience, temporal, and governance contexts that make up the offerings.</li> <li>Operational Management: Admins manage inventory, monitor bookings, and adjust operational parameters to ensure smooth functioning of the system.</li> <li>Reporting and Analytics: Admins analyze data on bookings, user behaviour, and system performance to inform decision-making and optimize the reservation system.</li> </ul>"},{"location":"contexts/admin-user-journey-phases/#experience-configuration","title":"Experience Configuration","text":"<p>Administrators set up and configure the various contexts that define the offerings in the reservation system. This includes:</p> <ul> <li>Defining spatial contexts such as geozones and facilities.</li> <li>Creating experience definitions that specify the nature of the offerings, such as Activities and Products.</li> <li>Setting temporal availability and concurrency through ProductDates and Inventory.</li> </ul>"},{"location":"contexts/admin-user-journey-phases/#configuring-the-spatial-context","title":"Configuring the Spatial Context","text":"<pre><code>flowchart LR\n\n    A[Admin defines a Collection] --&gt; B[Admin creates Geozones] &amp; C[Admin creates Facilities] &amp; D[Admin creates Activities]\n    B --&gt; E[Linked Geospatially] &amp; F[\"Linked explicitly (optional)\"]\n    C --&gt; E\n    C --&gt; F\n    D --&gt; F\n</code></pre> <p>Admins define the spatial context by creating and managing geozones, facilities, activities and other spatial concepts. This helps public users in the Discovery Phase understand where experiences are located and what spatial boundaries apply.</p>"},{"location":"contexts/admin-user-journey-phases/#configuring-the-experience-context","title":"Configuring the Experience Context","text":"<p>Admins create and manage experience definitions through Policies, Products, and ProductDates. This allows them to specify what experiences are offered, how they are structured, and how they evolve over time. By configuring the experience context, admins shape the offerings that users interact with throughout their journey, particularly in the Alignment Phase.</p> <p>Ideally, admins will curate an experience long before it is intended to be discoverable by the public. This allows ample time to configure the spatial, experience, temporal, and governance contexts in a way that creates a seamless and intuitive user journey when the experience is eventually released. The system is optimized for this workflow - the bulk of the work happens upfront and ahead of time, such that the runtime public user experience is fast and intuitive, without any need for complex decisioning or configuration at the moment of booking.</p>"},{"location":"contexts/admin-user-journey-phases/#creating-an-experience","title":"Creating an Experience","text":"<pre><code>flowchart LR\n    A[Admin creates a Product] --&gt; B[Admin seeds ProductDates]\n    B --&gt; C[Admin tweaks ProductDates with date-specific details and rules]\n    C --&gt; D[Admin seeds Inventory for ProductDates]\n</code></pre> <p>In the beginning of the public user Alignment Phase, public user are matching their experience intent with the available offerings. From a single Activity (experience), administrators can create multiple Products that represent different ways to obtain that experience (offerings). Each Product is a self-contained offering with its own suite of rules and parameters. This allows administrators to create a variety of offerings around a single experience, each with different rules, availability, and constraints.</p> <p>Products are comprised of rules that apply at different scopes. Some rules apply to the whole offering (time-independent scope), while others apply to specific dates or times (time-dependent scope). By configuring these rules, administrators can create offerings that change in availability, price, or other parameters based on time. This allows for dynamic offerings that can adapt to different days of the week, demand levels, or other operational needs.</p> <p>Generic rules that govern things like discoverability, reservability, party sizes, fees, cancellation requirements, etc. are defined as Policies and attached to Products at creation time. This allows for consistent application of rules across multiple offerings and simplifies the management of common parameters.</p> <p>During the lifecycle of the offering, governing rules are resolved as soon as possible. This means that resolved rules are stored with the Product and ProductDate items, rather than refrerencing a Policy and being calculated at runtime. This design choice optimizes for a fast and seamless booking experience for public users, as the system can quickly retrieve pre-resolved rules without needing to perform complex calculations at the moment of booking.</p> <p>The downside to this approach is that governing structures are difficult to amend once the public user journey has begun, as any changes to the rules would require updating all related Product and ProductDate items with the new resolved values. For this reason, it is critical that administrators carefully configure and review all governing rules during the experience configuration phase, before the offering becomes discoverable to the public.</p> <p>The following steps are typical in the creation of an offering:</p>"},{"location":"contexts/admin-user-journey-phases/#admin-creates-a-product","title":"Admin creates a Product","text":"<ul> <li>Product is derived from parent Activity and inherits key properties such as <code>collectionId</code>, <code>activityType</code>, and <code>activityId</code>, which are used to construct the partition key for the Product.</li> <li>A unique <code>productId</code> is generated for each Product, which is used to construct the sort key for the Product and its related items.</li> <li>Public-facing Product details such as name and description are defined at this stage, which will be visible to visitors when they discover the offering.</li> <li>The timezone is defined, which will be used for all date and time calculations related to the Product.</li> <li>A calendar date range is defined, which specifies the initial range of dates for which ProductDates will be seeded.</li> <li>The list of Assetsgoverned by the Product and their daily available quantites  is defined, which will be passed to ProductDates and used for Inventory management and availability estimation.</li> <li>The <code>availabilityEstimationPattern</code> is defined, which specifies how availability should be estimated for ProductDates related to this Product. This pattern will be inherited by the ProductDates and used in availability calculations.</li> <li>Itinerary rules are defined, which indicate whether visitors should supply their intended itinerary when making a reservation, including the entry and exit Facilities.</li> <li>Waitroom configuration is defined (future state).</li> <li>The <code>allDatesReservedInterval</code> is defined, which specifies a string of calendar dates within which all reservations of this Product that contain Inventory from those dates must ensure that inventory from ALL of those dates are included in the reservation. This is used to enforce rules around offerings that require continuous inventory across multiple dates (e.g., a multi-day tour that requires inventory on each day of the tour).</li> <li>The general reservation policy is linked, which will govern reservation policies for the Product, and be inherited by ProductDates. This policy can be overridden at the ProductDate level if needed.</li> <li>From the general reservation policy, the following Product-level values are resolved at Product creation time:</li> <li><code>isDiscoverable</code>: Indicates whether the Product should be visible to visitors during discovery.</li> <li><code>isReservable</code>: Indicates whether the Product can be reserved by visitors.</li> <li><code>minTotalDays</code>: The minimum total days required for a reservation of this Product.</li> <li><code>maxTotalDays</code>: The maximum total days allowed for a reservation of this Product.</li> <li><code>temporalWindows.discoveryWindow</code>: The time window during which the Product is discoverable by visitors, if <code>isDiscoverable</code> is true.</li> <li>The general booking policy is linked, which will govern booking policies for the Product, and be inherited by ProductDates. This policy can be overridden at the ProductDate level if needed.</li> <li>The general fee policy is linked, which will govern fee policies for the Product, and be inherited by ProductDates. This policy can be overridden at the ProductDate level if needed.</li> <li>From the general fee policy, any Product-level fee rules are resolved at Product creation time, which will be applied to reservations of this Product. This includes:</li> <li><code>feeSchedule</code>: The schedule of fees that should be applied to reservations of this Product, which may include one-time fees, transaction fees, taxes, and other Product/Booking-level fee types.</li> <li><code>lineItems</code>: The specific line items that should be applied to reservations of this Product, which define how <code>feeSchedule</code> fees are applied based on Product/Booking-level details.</li> <li>The general change policy is linked, which will govern change policies for the Product, and be inherited by ProductDates. This policy can be overridden at the ProductDate level if needed.</li> </ul> <p>At the end of this stage, the Product item is created, which serves as the parent for all related ProductDate items. The Product contains all the high-level information about the offering, while the ProductDates will contain date-specific information and availability tracking.</p>"},{"location":"contexts/admin-user-journey-phases/#admin-seeds-productdates","title":"Admin seeds ProductDates","text":"<pre><code>flowchart LR\n  A[Product] ---&gt; B[ProductDate 1] &amp; C[ProductDate 2] &amp; D[ProductDate 3]\n  B --&gt; E[AvailabilitySignal 1]\n  C --&gt; F[AvailabilitySignal 2]\n  D --&gt; G[AvailabilitySignal 3]\n</code></pre> <p>Once the Product is created, administrators can trigger a ProductDate seed. This action generates one ProductDate item for each date between the <code>rangeStart</code> and <code>rangeEnd</code> defined on the Product. Each ProductDate inherits key properties from the parent Product and resolves any time-dependent values that are needed for Inventory seeding and vistor discovery/reservation.</p> <ul> <li>Each ProductDate inherits the partition key and sort key from from the parent Product, which is used to construct the partition key for the ProductDate and its related items.</li> <li>The date of which the ProductDate represents is defined, and serves as the ProductDate's sort key.</li> <li>An AvailabilitySignal is created for the ProductDate, and the primary key is stored to the ProductDate.</li> <li>The list of Assets and their daily available quantities is inherited from the parent Product, and stored on the ProductDate for use in Inventory management and availability estimation.</li> <li>If the date falls within an <code>allDatesReservedInterval</code>, that interval is stored on the ProductDate to be used in reservation validation for reservations that include inventory from that date.</li> <li>The date-specific reservation policy is inherited from the Product, which will govern daily reservation policies for this ProductDate, and be inherited by reservations of this ProductDate. This policy can override the Product-level reservation policy if needed.</li> <li>From the date-specific reservation policy, the following ProductDate-level values are resolved at ProductDate seeding time:</li> <li><code>isDiscoverable</code>: Indicates whether the ProductDate should be visible to visitors during discovery.</li> <li><code>isReservable</code>: Indicates whether the ProductDate can be reserved by visitors.</li> <li><code>minDailyInventory</code>: The minimum daily inventory required for a reservation of this ProductDate.</li> <li><code>maxDailyInventory</code>: The maximum daily inventory allowed for a reservation of this ProductDate</li> <li><code>temporalWindows.discoveryWindow</code>: The time window during which the ProductDate is discoverable by visitors, if <code>isDiscoverable</code> is true.</li> <li><code>temporalWindows.reservationWindow</code>: The time window during which this ProductDate can be reserved by visitors, if <code>isReservable</code> is true.</li> <li><code>temporalWindows.restrictedBookingWindow</code>: Bookings including Inventory from this ProductDate are banned from making changes/cancellations if they are within this time window, if defined.</li> <li>The date-specific booking policy is inherited from the Product, which will govern daily booking policies for this ProductDate, and be inherited by reservations of this ProductDate. This policy can override the Product-level booking policy if needed.</li> <li>The date-specific fee policy is inherited from the Product, which will govern daily fee policies for this ProductDate, and be inherited by reservations of this ProductDate. This policy can override the Product-level fee policy if needed.</li> <li>From the date-specific fee policy, any ProductDate-level fee rules are resolved at ProductDate seeding time, which will be applied to reservations of this ProductDate. This includes:</li> <li><code>feeSchedule</code>: The schedule of fees that should be applied to reservations of this ProductDate, which may include per-inventory fees, per-day fees, per-party member fees, taxes, and other ProductDate/BookingDate-level fee types.</li> <li><code>lineItems</code>: The specific line items that should be applied to reservations of this ProductDate, which define how <code>feeSchedule</code> fees are applied based on Product/Booking-level details.</li> </ul> <p>Note - change policies are independent of time, and therefore do not have ProductDate-level values that need to be resolved at seeding time.</p> <p>At the end of this stage, the offering is comprised of a Product item that defines the overall offering, and multiple identical ProductDate items, one for each date in the defined date range. Each ProductDate has an associated AvailabilitySignal that is used to track availability changes for that date.</p>"},{"location":"contexts/admin-user-journey-phases/#productdate-enhancements-and-adjustments","title":"ProductDate Enhancements and Adjustments","text":"<pre><code>flowchart LR\n  A[Seeded ProductDate] --&gt;|Administrator makes changes| B[Updated ProductDate with date-specific details and rules]\n</code></pre> <p>After the initial ProductDate seeding, administrators can make changes to the ProductDate details as needed. This includes updating the list of Assets and their daily available quantities, changing time-dependent reservation/booking/fee policies, and other date-specific details.</p> <p>The following properties can be updated during this stage: - The list of Assets and their daily available quantities can be updated to reflect changes in the offering or inventory levels. This may involve adding new Assets, removing existing Assets, or changing the available quantities for existing Assets. - Time-dependent reservation policies can be updated to reflect changes in reservation rules or policies. For example, the discovery or reservation windows may be adjusted, or the minimum/maximum inventory requirements may be changed. - Time dependent booking policies can be updated to reflect changes in booking rules or policies. For example, the allowed daily party compositions and equipment requirements may be changed. - Time dependent fee policies can be updated to reflect changes in fee rules or policies. For example, a Product may charge more on weekends than weekdays, so the fee schedule may be updated to reflect this, or a new per-party member fee may be added for certain dates.</p> <p>At the end of this stage, the offering is fully defined. No changes to Product-level or ProductDate-level scope properties can be made after this stage.</p>"},{"location":"contexts/admin-user-journey-phases/#administrators-seed-inventory","title":"Administrators seed Inventory","text":"<pre><code>flowchart LR\n  A[ProductDate] --&gt; B[Inventory for Asset 1 on date]\n  A --&gt; C[Inventory for Asset 2 on date]\n  A --&gt; D[Inventory for Asset 3 on date]\n</code></pre> <p>The final stage of experience creation is seeding Inventory for the ProductDates. This involves creating Inventory items for each Asset governed by the Product, for each ProductDate. Each Inventory item represents the intersection of a specific date and the quantity of a specific Asset that is available on that date.</p> <p>At the end of this stage, the offering is fully available for discovery and reservation by visitors. The Product and ProductDate items define the details of the offering, while the Inventory items define the specific availability of each Asset on each date. The AvailabilitySignal items are used to track changes in availability for each ProductDate, allowing the system to maintain up-to-date availability information for visitors during discovery and reservation.</p> <p>See public Alignment Phase for how these schemas are used in the public user journey.</p> <p>Final Layout</p> <pre><code>flowchart LR\n  A[Product] --&gt; b[ProductDate 1] &amp; c[ProductDate 2] &amp; d[ProductDate 3]\n  b[ProductDate 1] --&gt; e[Inventory for Asset 1 on date] &amp; f[Inventory for Asset 2 on date] &amp; g[Inventory for Asset 3 on date]\n  c[ProductDate 2] --&gt; h[Inventory for Asset 1 on date] &amp; i[Inventory for Asset 2 on date] &amp; j[Inventory for Asset 3 on date]\n  d[ProductDate 3] --&gt; k[Inventory for Asset 1 on date] &amp; l[Inventory for Asset 2 on date] &amp; m[Inventory for Asset 3 on date]\n</code></pre>"},{"location":"contexts/admin-user-journey-phases/#operational-management","title":"Operational Management","text":"<p>Administrators oversee the day-to-day operations of the reservation system, ensuring that it runs smoothly and efficiently. This involves:</p> <ul> <li>Monitoring inventory levels and adjusting availability as needed.</li> <li>Managing bookings and user interactions to resolve issues and provide support.</li> <li>Responding to real-time events and making operational adjustments to maintain service quality.</li> </ul>"},{"location":"contexts/admin-user-journey-phases/#reporting-and-analytics","title":"Reporting and Analytics","text":"<p>Administrators analyze data collected from the reservation system to gain insights and make informed decisions. This includes:</p> <ul> <li>Tracking booking trends and user behaviour to identify opportunities for improvement.</li> <li>Evaluating system performance and identifying areas for optimization.</li> <li>Generating reports to inform strategic planning and operational adjustments.</li> </ul>"},{"location":"contexts/data-categorization/","title":"Data Categorization","text":"<p>The PRDT data model organizes all data into the following categories based on expected read/write intensity. This separation allows DynamoDB tables to be tuned for their specific workload patterns.</p>"},{"location":"contexts/data-categorization/#reference-data","title":"Reference Data","text":"<p>Reference data consists of long\u2011lived, persistent, and mostly static information. It is read frequently and updated infrequently. Reference data is read\u2011optimized and stored in a DynamoDB table configured for high\u2011read throughput and predictable access patterns.</p>"},{"location":"contexts/data-categorization/#transactional-data","title":"Transactional Data","text":"<p>Transactional data consists of short\u2011lived, dynamic, and frequently updated information. It represents user actions or system events that change often. Transactional data is write\u2011optimized and stored in a DynamoDB table configured for high\u2011write throughput and rapid mutation.</p>"},{"location":"contexts/data-categorization/#relational-data-future-state","title":"Relational Data (Future State)","text":"<p>Relational data represents the connections between reference data items rather than the items themselves. These schemas capture two\u2011way, many\u2011to\u2011many relationships as bidirectional adjacency lists. Relational Data is intentionally lightweight and connection\u2011oriented. Each item expresses a single relationship and contains only the minimal information required to support efficient lookup in both directions. Its access patterns should be balanced: optimized enough to support fast traversal of the graph, but simple enough to remain flexible as the domain evolves. Relationship data does not necessarily need its own DyanmoDB table, but rather intelligently-designed GSIs.</p> <p></p>"},{"location":"contexts/data-contexts/","title":"The Contexts of the Data Model","text":"<p>This data model is intentionally structured around several distinct contexts that describe every offering. Separating schemas based on these contexts ensure the system remains flexable, scalable, and capable of supporting any current or future experience type.</p> <p>Each context encapsulates different aspects about any offering:</p> <ul> <li>Spatial context: Where does it occur?</li> <li>Intent context: What is the experience?</li> <li>Temporal context: When is it available?</li> <li>Governance context: How is it governed, restricted, or made available to users?</li> <li>Identity context: Who is interacting with it?</li> </ul> <p></p> <p>In the detailed descriptions below, note that some schemas fall in to more than one category. This is intentional as these types often provide logical bridges between contexts.</p>"},{"location":"contexts/data-contexts/#spatial-context","title":"Spatial Context","text":"<p>\"Where does the experience occur?\"</p> <p>Spatial context describes the physical location or region associated with an experience.</p> <p>Spatial data answers where an experience takes place, independent of what the experience is or when it occurs. Spatial boundaries change slowly, but experiences and schedules change frequently.</p> <p>By isolating spatial data, the system avoids unnecessary duplication and can support: - multi\u2011park experiences - partial\u2011park experiences - user\u2011defined regions - future non\u2011park experiences</p>"},{"location":"contexts/data-contexts/#intent-context","title":"Intent Context","text":"<p>\"What is the user doing?/What is the user wanting to do?\"</p> <p>Intent context defines the nature of the offering itself.</p> <p>The intent layer answers what the experience is, independent of when it is offered. In some cases, the spatial context overlaps, as where an experience occurs quite often goes hand in hand with exactly what the experience is. Intent definitions evolve over time. New activities or product types can be introduced without restructuring spatial or temporal data. This keeps the model experience\u2011agnostic and future\u2011proof.</p>"},{"location":"contexts/data-contexts/#temporal-context","title":"Temporal Context","text":"<p>\"When is the experience offered?\"</p> <p>Temporal context describes the time\u2011based availability of an experience.</p> <p>The temporal layer answers when an experience is available. Temporal data changes frequently - yearly, seasonally, daily, sometimes faster. By isolating temporal context, the system can: - regenerate schedules without touching spatial or experience data - support rolling availability - handle seasonal changes cleanly - scale to millions of date\u2011specific items</p>"},{"location":"contexts/data-contexts/#governance-context","title":"Governance Context","text":"<p>\"How is the experience made available?\"</p> <p>Governance context defines the rules, constraints, and behaviours that control how an experience is offered.</p> <p>This layer answers how the system regulates access to the experience. Governance rules change independently of location, experience type, or schedule. By isolating governance: - capacity, pricing, and other operational rules can change on a daily cadence without changing other aspects of the experience - multiple experiences can share the same operational rules</p>"},{"location":"contexts/data-contexts/#identity-context","title":"Identity Context","text":"<p>\"Who is interacting with the experience\"</p> <p>The identity context describes the users, administrators, and system actors who interact with PRDT. It includes authentication state, roles, and permissions that determine what data is visible, what actions are allowed, and how governance rules are applied. Closely linked to governance context, identity is a cross\u2011cutting context that influences behaviour across spatial, experience, and temporal layers.</p>"},{"location":"contexts/public-user-journey-phases/","title":"Public User Journey Phases","text":"<p>Public visitors must be able to navigate the reservation system intuitively, without needing deep knowledge of the underlying data model. Most user journeys follow three distinct phases of interaction.</p> <ul> <li>Discovery</li> <li>Alignment</li> <li>Commitment</li> </ul> <p>Public visitors move through these phases as personal user journeys.</p>"},{"location":"contexts/public-user-journey-phases/#discovery-phase","title":"Discovery Phase","text":"<p>The Discovery Phase is where users begin their journey, typically by arriving on a public\u2011facing landing page. At this point, the system cannot assume any level of familiarity.</p> <p>Users may have - Extensive system knowledge \"I know what I am looking for and I know how to find it.\" - No system knowledge \"I am not sure what I am looking for or how to start looking for it.\" - Anything in between A partial understanding of the system and its capabilities.</p> <p>Because of this wide range of familiarity, the system must introduce itself clearly to newcomers while still allowing experienced users to move quickly. The Discovery Phase is designed to support both: it exposes the breadth of what the system can do while enabling direct navigation for those who already know their path.</p>"},{"location":"contexts/public-user-journey-phases/#ideal-discovery-flow","title":"Ideal Discovery Flow","text":"<p>The data model is optimized to resolve user intent in the following order:</p> <p>where -&gt; what -&gt; when</p> <p>This order was chosen because: - Users often begin with a place in mind, even if vague. - Activities (intent) become meaningful only once anchored to a location. - Temporal context (availability, pricing, policies) can only be resolved once the offering is known</p>"},{"location":"contexts/public-user-journey-phases/#how-the-data-model-currently-supports-discovery","title":"How the Data Model Currently Supports Discovery","text":"<p>With the help of OpenSearch, the system currently supports full text searching. By using the <code>searchTerms</code> property on geozones, facilities, and activities, searching for a shared term among several datatypes will return them in a query.</p> <p>Example: If a user enters 'Bedwell', they should be returned a list of geozones, facilities and activities that relate to the Bedwell Lake Area in Strathcona Park</p>"},{"location":"contexts/public-user-journey-phases/#how-a-future-data-model-state-might-bolster-discovery","title":"How a Future Data Model State Might Bolster Discovery","text":""},{"location":"contexts/public-user-journey-phases/#relationship-schemas","title":"Relationship Schemas","text":"<p>Geozones, facilities, and activities form a graph\u2011shaped network of two-way-linked, many\u2011to-many relationships. Because DynamoDB does not support joins, and foreign keys become complicated to manage as the system scales, these relationships should be represented explicitly as relationship items.</p> <p>A relationship item stores a single edge in the graph. The <code>pk</code>/<code>sk</code> pair provides the forward lookup, and a GSI provides the reverse lookup, enabling efficient two\u2011way navigation between domain objects. This pattern is the standard NoSQL approach for modeling many\u2011to\u2011many relationships.</p> <p>Example: The Bedwell Lakes Backcountry Camping Activity is two-way-linked to the Bedwell Lakes Trail Area Geozone. A potential relationship data item that conveys this link might look like the following JSON example: <pre><code>{\n  \"pk\": \"rel::activity::bcparks_1::backcountryCamp::1\"           // Forward query pk = the compound primary key of the first item, separated by '::'\n  \"sk\": \"geozone::bcparks_1::2\"                                  // Forward query sk = the compound primary key of the second item, separated by '::'\n  \"schema\": \"relationship\",\n  \"schema1\": \"activity\",                                         // The schema of the first item\n  \"schema2\": \"geozone\",                                          // The schema of the second item\n  \"pk1\": \"activity::bcparks_1\",                                  // The pk of the first item (optional)\n  \"pk2\": \"geozone::bcparks_1\",                                   // The pk of the second item (optional)\n  \"sk1\": \"backcountryCamp::1\",                                   // The sk of the first item (optional)\n  \"sk2\": \"2\",                                                    // The sk of the second item (optional)\n  \"gsipk\": \"rel::geozone::bcparks_1::2\",                         // Reverse query pk = the compound primary key of the second item, separated by '::' (GSI partition key)\n  \"gsisk\": \"activity::bcparks_1::backcountryCamp::1\"             // Reverse query sk = the compound primary key of the first item, separated by '::' (GSI sort key)\n}\n</code></pre></p> <p>This relationship schema provides a separation of duties, and keeps geozones, facilities, and activities truly within their respective spatial and intent contexts.</p> <p>Questions that this future state can help answer:</p> <ul> <li>\"I know where I want to go, but I dont know what's available or when\"</li> <li>Navigate to a geozone or facility and see the activities associated with the location.</li> <li>\"I know what I want to do, and I have a vague idea of where I want to go, but I don't know exactly where it's available or when\"</li> <li>Search by activity -&gt; shows activityType and the geozones and facilities where it is offered.</li> </ul>"},{"location":"contexts/public-user-journey-phases/#search-by-activitytype","title":"Search by ActivityType","text":"<p>Activities include both an activityType (the generalized experience) and a location\u2011scoped identity that distinguishes where that experience occurs. For example, Backcountry Camping in Strathcona Park and Backcountry Camping in E.C. Manning Park share the same activityType but occur in vastly different locations, and are therefore represented by different activities.</p> <p>Some visitors may begin their journey with a clear sense of what they want to do, but little or no preference for where it happens. Searching by activityType supports this intent, but because there are only a small number of activityTypes, a query at this level can return a very large set of results.</p> <p>Questions this future state can help answer:</p> <ul> <li>\"I know what I want to do, but I don't know when it's available, and I don't care where\"</li> <li>Without any spatial narrowing, a broad activityType (e.g., \u201cbackcountry camping\u201d) may return hundreds of results across the province. Many of these results will not be meaningful to the user, who likely has implicit geographic constraints (travel distance, region, familiarity).</li> </ul> <p>This query is still technically supportable, but the system should encourage users to provide at least a general sense of place to avoid overwhelming or irrelevant results.</p>"},{"location":"contexts/public-user-journey-phases/#date-first-querying","title":"Date-First Querying","text":"<p>None of the Discovery Phase schemas include temporal context. This makes the question:</p> <ul> <li>\"I know when I want to go, but I don't know where or what I want to do\"</li> </ul> <p>...difficult to answer at this stage. Supporting this journey would require live availability indexing across the entire system - something only possible once the operational data model is fully stable. This makes it a strong candidate for future enhancement rather than a core Discovery Phase feature.</p>"},{"location":"contexts/public-user-journey-phases/#alignment-phase","title":"Alignment Phase","text":"<p>Once users understand what exists - the places, facilities and activities available in the system - they move into the Alignment Phase, where the system begins translating their interests into concrete, reservable offerings. This is the moment where intent meets operational reality.</p> <p>In this phase, users shift from broad exploration to evaluating specific options. They are no longer asking \"What can I do?\" but rather:</p> <ul> <li>\"What does BC Parks offer that matches what I want?\"</li> <li>\"When is it available?\"</li> <li>\"What rules or constraints apply?\"</li> </ul> <p>The Alignment Phase is where the system resolves these questions by mapping user intent to actual, date-specific offerings.</p> <p>These schemas introduce the temporal and governance contexts absent in the Discovery Phase. Together, they form the bridge between high-level exploration and concrete booking options. Regardless of how users arrived from the Discovery Phase, the Alignment Phase answers:</p> <ul> <li>\"I see what they've got in relation to what I want\"</li> </ul> <p>... and ensures the user is looking at valid, operationally grounded choices.</p> <p>The following steps are typical in the Alignment Phase:</p>"},{"location":"contexts/public-user-journey-phases/#visitors-make-reservation-request","title":"Visitors Make Reservation Request","text":"<p>When a visitor decides to make a reservation for a Product, they submit a reservation request. Depending on the structure of the Product, the visitor may be prompted to provide:</p> <ul> <li>A date or list of continuous dates they wish to reserve.</li> <li>The quantity of each Asset they wish to reserver on each date.</li> <li>Some Products may allow a maximum of 1 Inventory item per date (e.g. offerings for a campsite). In these cases, the reservation request would only prompt for a date or list of continuous dates, and the system would assume a quantity of 1 for each date.</li> <li>Some Products may allow multiple Inventory items per date (e.g. trail passes) but may only allow 1 date per reservation. In these cases, the reservation request would prompt for a date and the quantity of each Asset they wish to reserve for that date.</li> <li>Some Products may allow multiple Inventory items per date, and multiple dates per reservation (e.g. backcountry reservations may allow this?).</li> </ul> <p>The system validates the reservation request against the reservation policies defined on the Product and ProductDate items, as well as the availability of the items by verifying available Inventory items. If the reservation request is valid and there is sufficient availability, the system creates a Booking and related BookingDates for the visitor and updates the relevant Inventory and AvailabilitySignal items to reflect the new reservation.</p> <ul> <li>Visitor's request timestamp is recorded and validated against <code>isReservable</code> and the <code>temporalWindows.reservationWindow</code> defined on each ProductDate included in the reservation request.</li> <li>The reservation request is validated against the <code>minTotalDays</code> and <code>maxTotalDays</code> defined on the Product reservation policy.</li> <li>Visitor's <code>arrivalDate</code> and <code>departureDate</code> are recorded.</li> <li>The <code>checkInAnchor</code> and <code>noShowAnchor</code> are determined based on the visitor's <code>arrivalDate</code> and the Product's timezone.</li> <li>THe <code>checkOutAnchor</code> is determined based on the visitor's <code>departureDate</code> and the Product's timezone.</li> <li>The reservation request is validated against any <code>allDatesReservedIntervals</code> defined on the Product.</li> <li>A BookingDate is created for each date included in the reservation request.</li> <li>Each Inventory item requested is recorded and validated against the <code>minDailyInventory</code> and <code>maxDailyInventory</code> defined on each ProductDate included in the reservation request. Each BookingDate records the specific Inventory items reserved for that date.</li> <li>The reservation request is inspected to see if any <code>restrictedBookingWindow</code> defined on any ProductDate included in the reservation request is triggered. If so, the reservation is marked as final-sale.</li> </ul>"},{"location":"contexts/public-user-journey-phases/#visitors-enhance-alignment-with-additional-context","title":"Visitors Enhance Alignment with Additional Context","text":"<p>Once a Booking has been initialized, visitors can make changes that do not affect Inventory allocation before finalizing the reservation. This changes may include:</p> <ul> <li>Visitors add or remove party members if it does not impact Inventory allocation</li> <li>Visitors add or remove equipment if it does not impact Inventory allocation</li> <li>Visitors update contact information</li> <li>Visitors apply discount codes or vouchers</li> </ul> <p>These changes are validated against the booking policies defined on the Product and ProductDate items, and the Booking and related BookingDates are updated accordingly. They may influence fees applied to the reservation, but do not require re-validation of availability or Inventory allocation.</p> <p>Changes that impact Inventory allocation incur a re-validation of the reservation request against availability and reservation policies. Early iterations may not support these changes pre-finalization, and may require visitors to cancel and rebook if they wish to make such changes. These changes may include:</p> <ul> <li>Visitors changing dates of the reservation</li> <li>Visitors changing quantity of Assets reserved</li> <li>Visitors lengthening or shortening the reservation</li> <li>Visitors changing party composition that impacts Inventory allocation</li> <li>Visitors changing equipment that impacts Inventory allocation</li> </ul>"},{"location":"contexts/public-user-journey-phases/#commitment-phase","title":"Commitment Phase","text":"<p>Once public users have identified a specific offering that aligns with their intent, they enter the Commitment Phase. This is where the system formalizes the user's choice by allocating inventory, applying policies, and completing financial transactions. It is the moment where a user's interest becomes an operational obligation.</p> <p>In this phase, the system must ensure that - The inventory being claimed is valid and unambiguously owned - The governing rules are correctly applied - The user's identity and party details are captured - Financial transactions, if any, are processed - The booking is recorded in a durable, auditable form</p> <p>Schemas that support the Commitment Phase are</p> <ul> <li>Bookings</li> <li>Users</li> <li>Transactions</li> <li>Policies</li> </ul> <p>Regardless of path, the Commitment Phase answers:</p> <ul> <li>\"I've got what I want - or the closest available option - and I am ready to commit\".</li> </ul> <p>This phase transforms the user's journey from exploration and evaluation into a legally and operationally binding commitment.</p> <p>The Commitment Phase is the most operationally sensitive part of the user journey, where concurrency, policy enforcement, and financial correctness must all converge.</p>"},{"location":"data-model/data-storage/","title":"DynamoDB Partitioning","text":"<p>DynamoDB is the authoritative data store for most reference data in the PRDT system. All schemas use a compound primary key consisting of:</p> <ul> <li>pk - the partition key</li> <li>sk - the sort key</li> </ul> <p>This structure groups related items together and ensures predictable, efficient queries. Combined, the <code>pk</code> and <code>sk</code> must be unique system-wide.</p> <p>To maintain consistency across all schemas, <code>pk</code>/<code>sk</code> values should aim to follow a shared naming convention.</p>"},{"location":"data-model/data-storage/#partition-key-pk","title":"Partition Key (pk)","text":"<p>The partition key identifies a logical grouping of related items.</p> <p>It should always begin with the schema name of the datatype the <code>pk</code> identifies.</p> <p>It should aim to be human-guessable and predictable to support debugging and manual queries.</p> <p>Additional scoping properties should be appended when needed. For example, the <code>collectionId</code> is the backbone that groups experiences together logically. Appending <code>collectionId</code> will scope the partition to focus on items related by <code>collectionId</code>.</p> <pre><code>// Example pk for geozone for collection with collectionId bcparks_1\npk: geozone::bcparks_1\n</code></pre>"},{"location":"data-model/data-storage/#sort-key-sk","title":"Sort Key (sk)","text":"<p>The sort key uniquely identifies an item within a partition.</p> <p>It should be concise, predictable, and structured to support efficient queries.</p> <p>It should aim to be human-guessable and predictable to support debugging and manual queries.</p> <p>General sk rules: * If the number of items in a partition is unbounded    * If the order items are created in matters, or the <code>sk</code> is to remain human-readable, use an atomically incrementing identifier.    * If the order does not matter and the <code>sk</code> does not need to remain human-readable, a UUID may suffice (less overhead on POST). * If the number of items in a partition is projected to remain theoretically finite, use naturally unique properties to distinguish the item within a partition (e.g., productDates will have at most 1 item per day in each productDate partition, so use the short date to distinguish partition items), * Some schemas may use a combination of approaches</p> <pre><code>// Example pk/sk: productDate for 2025-12-31 for product #1 of dayuse activity #1 in collection bcparks_1\npk: productDate::bcparks_1::dayuse::1\nsk: 1::2025-12-31\n</code></pre>"},{"location":"data-model/data-storage/#global-identifiers-and-gsis","title":"Global Identifiers and GSIs","text":"<p>Some schemas benefit from a globalId (UUID) that uniquely identifies an item across the entire system.</p> <p>This is useful when items must be referenced individually of a collection or other parent structure (e.g., bookings, user-generated content).</p> <p>Leveraging a GSI on the <code>globalId</code> property can provide quick lookups for single items without having to know the item's data hierarchy or parent structure to craft its logical compound primary key.</p>"},{"location":"data-model/data-storage/#opensearch-partitioning","title":"OpenSearch Partitioning","text":"<p>OpenSearch is a distributed search and analytics engine that complements DynamoDB by supporting:</p> <ul> <li>full-text searching</li> <li>geospatial queries</li> <li>browsing and discovery search flows</li> </ul> <p>It supplements DynamoDB where DynamoDB is weakest, namely in broad, unstructured search querying. DynamoDB remains the authoritative source, but it remains synchronized with OpenSearch indexes via DynamoDB Streams.</p>"},{"location":"data-model/data-storage/#large-geospatial-data","title":"Large Geospatial Data","text":"<p>Some geospatial boundaries (e.g, polygons), exceed DynamoDB's item size limits. In these cases:</p> <ul> <li>The authoritative source becomes AWS S3</li> <li>The DynamoDB item stores a reference to the S3 source (URL)</li> <li>OpenSearch indexes the full geometry for spatial querying</li> </ul>"},{"location":"data-model/data-storage/#opensearch-document-ids","title":"OpenSearch document IDs","text":"<p>Unlike DynamoDB, OpenSearch requires a single unique ID per document. To ensure reversibility and consistency, these IDs are constructed from the corresponding DynamoDB pk/sk:</p> <pre><code>&lt;pk&gt;#&lt;sk&gt;\n</code></pre> <p>This guarantees a one-to-one mapping between DynamoDB and OpenSearch. Since OpenSearch may index streamed data from multiple tables, the previous assertion of</p> <p>Combined, the <code>pk</code> and <code>sk</code> must be unique system-wide.</p> <p>is a measure to prevent unintentional collisions across the various database services used in this project.</p>"},{"location":"data-model/introduction/","title":"Reservations Data Model \u2014 Summary","text":"<p>Written: 2024-11-15 Updated: 2026-02-11 Author: Team Osprey</p> <p>The PRDT data model is the foundation that allows BC Parks to offer any kind of outdoor experience \u2014 from campsites to cabins, trail passes, backcountry permits, parking, and future offerings we haven\u2019t imagined yet. It\u2019s designed to be flexible, scalable, and easy to maintain as park operations evolve.</p> <p>At its core, the model separates where an experience happens, what the experience is, when it\u2019s available, how it\u2019s governed, and who is interacting with it. By keeping these ideas separate, the system can adapt to new experience types, new rules, and new geographies without major redesign.</p>"},{"location":"data-model/introduction/#why-this-model-exists","title":"Why This Model Exists","text":"<p>BC Parks manages a huge variety of experiences. Most are contained entirely within parks - but some span multiple parks, and some only cover part of a park. Experiences also change seasonally, depend on geospatial boundaries, and require different rules or capacities.</p> <p>The data model provides a unified structure that can represent all of these cases consistently \u2014 even as offerings grow or change.</p>"},{"location":"data-model/introduction/#collections-the-toplevel-grouping","title":"Collections \u2014 The Top\u2011Level Grouping","text":"<p>Instead of using legally defined park boundaries (ORCS numbers), the system uses collections \u2014 flexible groupings that reflect real\u2011world operational needs. A collection may include: - one park - multiple parks - part of a park - areas that aren\u2019t parks at all</p> <p>Collections are not a schema or entity (yet) \u2014 they\u2019re labels used to group related reference data so the system can reason about an experience domain consistently.</p>"},{"location":"data-model/introduction/#example-collection-showing-discovery-elements","title":"Example Collection Showing Discovery Elements","text":""},{"location":"data-model/introduction/#example-collection-showing-complex-relationships-between-datatypes","title":"Example Collection Showing Complex Relationships Between Datatypes","text":""},{"location":"data-model/introduction/#important-datatypes","title":"Important Datatypes","text":"<ul> <li>Geozones - defined spatial boundaries that group assets or regions together so products, rules, and availability can be applied consistently across a specific geographic area.</li> <li>Facilities - specific, physical elements that describe real-world infrastructure or natural features that visitors interact with directly.</li> <li>Activities - generalized recreational opportunities - such as camping or trail use - that describe what experiences are potentially available to visitors at specific locations without factoring in when they are actually available or which reservation policies apply.</li> <li>Products  (WIP) - reservable offerings that define what is being booked along with the general policies and other operational parameters that govern how it can be reserved</li> <li>ProductDates (WIP) - fully resolved, day-specific configurations of a product that combine the governing policies into a single authoritative snapshot for that date.</li> <li>AvailabilitySignals (WIP) - lightweight, eventually-consistent, date-specific indicators of whether a product is likely to be available or unavailable, used to optimize search and browsing experiences by avoiding unnecessary inventory queries.</li> <li>Assets (WIP) - persistent logical units - usually physical but sometimes conceptual - that represent something whose ownership or allocation can change day-to-day. The non-temporal part of inventory.</li> <li>Inventory (WIP) - date-specific availability records for an asset, representing the smallest unit of reservable capacity and serving as the concurrency boundary for bookings.</li> <li>Policies (WIP) - define transferrable/shareable rules and conditions that govern how a product can be reserved or modified.</li> <li>Bookings (WIP) - Records that formalize a user\u2019s commitment to a specific offering by allocating inventory under the governing policies.</li> <li>BookingDates (WIP) - fully resolved, day-specific snapshots of a the governing policies and daily values in single authoritative record for that date, linked to the parent Booking.</li> <li>Users (WIP) - Individuals who interact with the system, carrying identity, roles, and permissions that shape what they can see or do.</li> <li>Transactions (WIP) - Financial records that capture the payment events associated with creating, modifying, or canceling a booking or multiple bookings.</li> <li>(Protected areas) - a legacy datatype representing a legally-defined park unit, represented in this model as a specialized geozone rather than its own datatype.</li> </ul>"},{"location":"data-model/introduction/#mermaid","title":"```mermaid","text":"<p>config:    flowchart:       curve: basis</p> <p>flowchart TD</p> <p>classDef geozone fill:yellow,color:black classDef facility fill:blue,color:white classDef activity fill:red,color:white classDef product fill:purple,color:white classDef asset fill:skyblue,color:black classDef productDate fill:magenta,color:white classDef policy fill:turquoise,color:black classDef inventory fill:orange,color:black classDef booking fill:lime,color:black classDef bookingDate fill:green,color:white classDef user fill:teal,color:white classDef transaction fill:olive,color:white</p> <p>B[Facilities]:::facility &amp; C[Activity]:::activity B &lt;--&gt; C D --&gt; F[ProductDate]:::productDate G[Policies]:::policy ---&gt; D &amp; F C ----&gt; D[Product]:::product B ------&gt; E[Asset]:::asset F --- H[Inventory]:::inventory E --&gt; H D -----&gt; I[Booking]:::booking J[BookingDate]:::bookingDate --&gt; I H ---&gt; J F ---&gt; J K[Transaction]:::transaction --&gt; I L[User]:::user ---&gt; I L --&gt;K ``` --&gt;</p>"},{"location":"data-model/introduction/#the-five-contexts-of-every-experience","title":"The Five Contexts of Every Experience","text":"<p>Every experience in the system is described through five independent \u201ccontexts.\u201d Each context answers a different question:</p>"},{"location":"data-model/introduction/#spatial-context-where-does-it-happen","title":"Spatial Context \u2014 \u201cWhere does it happen?\u201d","text":"<p>Defines the physical place or region. Definitions include geospatial datapoints.</p>"},{"location":"data-model/introduction/#intent-context-what-is-the-user-doing-or-what-does-the-user-want-to-do","title":"Intent Context \u2014 \u201cWhat is the user doing?\u201d or \"What does the user want to do?\"","text":"<p>Defines the nature of the experience. This layer is experience\u2011agnostic, so new experience types can be added without restructuring the rest of the model.</p>"},{"location":"data-model/introduction/#temporal-context-when-is-it-available","title":"Temporal Context \u2014 \u201cWhen is it available?\u201d","text":"<p>Defines schedules and availability. Temporal data changes frequently (seasonally, daily, even hourly), so isolating it keeps the system fast and maintainable.</p>"},{"location":"data-model/introduction/#governance-context-how-is-it-managed","title":"Governance Context \u2014 \u201cHow is it managed?\u201d","text":"<p>Defines rules, constraints, and operational behaviour. Governance can change independently of location, experience type, or schedule.</p>"},{"location":"data-model/introduction/#identity-context-who-is-interacting-with-it","title":"Identity Context \u2014 \u201cWho is interacting with it?\u201d","text":"<p>Defines users, roles, and permissions. Identity influences what people can see or do across all other contexts.</p> <p></p>"},{"location":"data-model/introduction/#how-data-is-stored","title":"How Data Is Stored","text":"<p>The model separates data into two major categories:</p> <p>Reference Data - Long\u2011lived, mostly static information (e.g., geozones, facilities, activities). - Stored in a read\u2011optimized DynamoDB table.</p> <p>Transactional Data - Short\u2011lived, frequently updated information (e.g., bookings, user interactions). - Stored in a write\u2011optimized DynamoDB table.</p> <p>DynamoDB is the authoritative source of truth, using predictable partition keys for consistent access patterns. DynamoDB excels at structured queries - in other words, if you know what you're looking for, DynamoDB can get it for you cheaply and quickly.</p> <p>OpenSearch is used for: - full\u2011text search - geospatial search - browsing and discovery</p> <p>It stays synchronized with DynamoDB through DynamoDB streams. OpenSearch excels where DynamoDB is weak - unstructured, fuzzy searching - and therefore serves as a supplementary data management tool.</p> <p>In both public and administrative user stories, the system will drive users towards DynamoDB queries as their journey gets more and more specific, but OpenSearch remains to serve broader browsing and discovery use cases.</p>"},{"location":"data-model/introduction/#in-plain-terms","title":"In Plain Terms","text":"<ol> <li> <p>This system sells experiences. Every experience is made of 5 ingredients: where, what, when, how, and who.</p> </li> <li> <p>This model keeps these ingredients independent enough that they can be mixed and matched in any combination, without rewriting the system when something changes.</p> </li> <li> <p>This strategic separation is what gives the system its flexibility. If we start blending these ingredients together in the wrong places, we lose extensibility and recreate the old system\u2019s problems.</p> </li> </ol> <p>The documented KPIs reflect the initial delivery slice (backcountry registrations), but the strategic intent expressed by leadership is to build a unified, extensible reservation platform. This data model was intentionally designed to satisfy both: it supports whichever reservations experience 'slice' must be addressed first, while providing a scalable foundation for all future offerings.</p>"},{"location":"data-model/primitive-property-types/","title":"Property Types","text":"<p>Below is a table of property data types to enforce uniform data representation across all datapoints.</p> Property Type Description <code>String</code> Primitive type <code>Number</code> Primitive type <code>Boolean</code> Primitive Type <code>TimeStamp</code> Full ISO timestamp, eg: <code>2025-01-01T00:00:00.000Z</code> <code>Date</code> Calendar date presented as an ISO-8601 Date (YYYY-MM-DD), eg: <code>2024-07-18</code> <code>Time</code> Time of day in 24h time, as ISO-8601 time (hhss(:fff)), eg <code>15:30:00</code> <code>Duration</code> A non-specific, continuous span of time, presented as an object, eg: <code>{days: 14}</code> (14 days) <code>Array[propertyType]</code> An array of <code>propertyType</code> <code>Enum</code> Enumerator - Special type that denotes a single value in a group of predefined/unchanging values <code>GeoJSON</code> Valid geoJSON. <code>OSGeo</code> OpenSearch-coded geospatial data. OSGeo is used for OpenSearch indexing and may differ from raw GeoJSON in structure or supported geometry types <code>Primary Key</code> DynamoDB primary key represented as an object; composed of a partition key (pk) and sort key (sk), eg: <code>{pk: 'PK', sk: 'SK'}</code> <ul> <li>Review luxon documentation regarding time-related property types.</li> </ul>"},{"location":"datatypes/activities/","title":"Activities","text":"<p>An activity represents a specific type of experience offered by BC Parks. Activities describe what a visitor can do and are anchored to specific places. They form the core of the intent context in this data model. They have semantic meaning in the generalized experience type they define, and spatial meaning without embedding themselves with spatial data and context.</p> <p>Activities are defined by - the type of experience (e.g., day\u2011use, camping, backcountry, boating), and - a relationship to a region or location where that experience is offered.</p> <p>If more than one activity of the same type is offered within the same collection, they are disambiguated using an atomically incrementing identifier (e.g., 1, 2, 3).</p> <p>Examples of activity types include: - Camping (frontcountry, backcountry, group) - Cabin use (frontcountry, backcountry) - Day\u2011use (parking, trail access, picnic shelters) - Boat launching - Canoe circuits</p> <p>Activities are not tied to any legacy BC Parks concept; they are a distinct datatype within this model.</p>"},{"location":"datatypes/activities/#relationship-to-facilities-and-geozones","title":"Relationship to Facilities and Geozones","text":"<p>Activities, facilities and geozones form many\u2011to\u2011many relationship. A single facility or geozone may support several activities, and an activity may span multiple facilities and/or geozones. However, every activity must be associated with at least one facility or geozone, since an activity represents an experience that must occur at a physical location.</p> <p>Activities, facilities and geozones exist at roughly the same level of the data hierarchy, but they represent different user search path - Geozones answer: \"Where do you want to go (roughly)?\" - Facilities answer: \u201cWhere do you want to go? (exactly)\u201d - Activities answer: \u201cWhat do you want to do? (by looking at ActivityType)\u201d</p> <p>Users may approach their searches by using either structure:</p>"},{"location":"datatypes/activities/#locationfirst-example","title":"Location\u2011first example","text":"<p>\u201cI want to go to Alouette Lake South Beach.\u201d \u2192 The facility shows the user which activities are available there (day\u2011use parking, boat launching).</p>"},{"location":"datatypes/activities/#experiencefirst-example","title":"Experience\u2011first example","text":"<p>\u201cI want to go backcountry camping (in Cape Scott or some other refined geospatial region such as the extents of a map on screen)\u201d \u2192 The activity shows the user which Cape Scott facilities/geozones support backcountry camping.</p> <p>ActivityTypes (activity property) assist in an even broader search type - they group together similar experiences that transcend locations. A user could ask a broader experience-first question:</p>"},{"location":"datatypes/activities/#broad-experience-first-example","title":"Broad experience-first example","text":"<p>\"I want to go backcountry camping (anywhere)\" \u2192 The system could pull a list of activities filtered by activityType = backcountry camping, but this list could be large so query limits should be in effect.</p>"},{"location":"datatypes/activities/#role-in-the-booking-flow","title":"Role in the Booking Flow","text":"<p>Activities are the primary entry point into the booking system. Once a user selects an activity, the system can guide them to: - the relevant facilities - the available products - the specific dates that activity/product is available (ProductDates) - the inventory and booking rules</p> <p>Activities are therefore the bridge between what the user wants to do and the specific reservable offerings (products).</p>"},{"location":"datatypes/activities/#example-what-an-activity-represents","title":"Example: What an Activity Represents","text":"<p>Bedwell Lakes Backcountry Camping is an activity. It carries semantic meaning because it belongs to the broader category of backcountry camping opportunities, a type of experience that comes with well-understood assumptions, expectations, and governance rules. However, the activity is not just an instance of that category. It is also anchored to the Bedwell Lakes Area, and therefore represents the specific backcountry experience associated with that place.</p> <p>This means the activity inherits the overarching themes of backcountry camping opportunities but remains its own distinct experience within the BC Parks system. It describes what the experience is, not whether it is currently offered.</p> <p>Looking up this activity at different times of year does not affect what a visitor would see. The activity is stable and conceptual. If the visitor wants to know when they can take advantage of this experience, they must look deeper into the operational layer (products and productDates). The activity simply answers the question:</p> <p>\"Are there ever backcountry camping opportunities at Bedwell Lakes?\"</p>"},{"location":"datatypes/activities/#spatial-relationships","title":"Spatial Relationships","text":"<p>Activities are partially defined by a relationship to spatial entities (geozones and/or facilities), but do not contain spatial data themselves. This relationship forms part of the bidirectional many-to-many graph outlined in the user's Discovery Phase.</p>"},{"location":"datatypes/activities/#properties","title":"Properties","text":"<p>Note: The activity configuration file is the authoritative source for the current schema.</p> Property Type Description <code>pk</code> String Partition key for the item. Always begins with <code>activity::&lt;collectionId&gt;</code>. Groups all activities within a collection. <code>sk</code> String Sort key uniquely identifying the item within the partition. Typically a combination of <code>activityType</code> and <code>identifier</code> <code>schema</code> String Item datatype/schema. Will always be 'activity' for activities <code>globalId</code> String UUID used for GSIs and cross\u2011collection lookups. <code>collectionId</code> String Identifier linking the activity to its operational collection (e.g., <code>bcparks_1</code>). <code>activityId</code> Number Identifier uniquely distinguishing this particular activity from other activities of the same type within the same collection <code>identifier</code> Number See <code>activityId</code> <code>activityType</code> String The type of activity the item represents. Some examples include \"frontcountryCamp\", \"backcountryCamp\", and \"groupCamp\" <code>activitySubType</code> String If needed, a further categorization of the <code>activityType</code>. Some examples of a \"dayuse\" <code>activitySubType</code> include \"trailUse\" or \"shelterUse\" <code>displayName</code> String Human\u2011readable name of the item. <code>description</code> String Optional descriptive text explaining the purpose or operational meaning of the item. <code>imageUrls</code> [String] Array of urls of images of this data item <code>timezone</code> String The IANA string timezone of the spatial data item <code>isVisible</code> Boolean Whether or not this item will be returned if it generates a search hit <code>creationDate</code> DateTime Timestamp of when the item was first created <code>lastUpdated</code> DateTime Timestamp of when the item was last updated <code>version</code> Number Data revision number <code>searchTerms</code> String Comma-separated list of terms OpenSearch can use to link text searches to this data item <code>adminNotes</code> String Administrative notes to describe the data, will never be surfaced to the public"},{"location":"datatypes/activities/#examples","title":"Examples","text":"<p>how to include mermaid charts in mkdocs - do i install mermaid2</p>"},{"location":"datatypes/activities/#bedwell-lake-backcountry-camping","title":"Bedwell Lake Backcountry Camping","text":"<pre><code>{\n  \"pk\": \"activity::bcparks_1\",\n  \"sk\": \"backcountryCamp::1\",\n  \"schema\": \"activity\",\n  \"globalId\": \"a9fds8hya-234d-t543-qw4r-gsodgnsdo\",\n  \"collectionId\": \"bcparks_1\",\n  \"activityId\": 1,\n  \"identifier\": 1,\n  \"activityType\": \"backcountryCamp\",\n  \"activitySubType\": \"\",\n  \"displayName\": \"Bedwell Lakes Trail\",\n  \"description\": \"The Bedwell Lake Trail in Strathcona Park offers a stunning, challenging hike through forest to a subalpine plateau with multiple lakes, featuring bridges, stairs, and rooty sections with incredible views of Mount Tom Taylor, making it great for day hikes or backpacking, with an optional, harder extension to Cream Lake. The trail is well-maintained but demanding, requiring good fitness, sturdy footwear, and potentially a high-clearance vehicle for the rough access road. Designated backcountry sites with outhouses and bear caches at Baby Bedwell Lake and Bedwell Lake; wilderness camping near Cream Lake.\",\n  \"imageUrls\": [\n    \"https://...\",\n    \"https://...\"\n  ],\n  \"isVisible\": true,\n  \"creationDate\": \"2026-01-07T15:30:00.000Z\",\n  \"lastUpdated\": \"2026-01-07T15:30:00.000Z\",\n  \"version\": 1,\n  \"searchTerms\": \"bedwell lake, baby bedwell lake, strathcona park...\",\n  \"adminNotes\": \"\"\n}\n</code></pre> <p>This activity would relate to a Bedwell Lakes Area geozone, the Bedwell and Baby Bedwell Lakes Campgrounds, and other spatial entities that support the Bedwell Lakes Backcountry Camping experience.</p>"},{"location":"datatypes/assets/","title":"Assets","text":"<p>Assets represent persistent, non-temporal physical or conceptual objects that can eventually become inventory when paired with a product/productDate. They are the \"things\" BC Parks manages that exist independently of time. They have spatial context as they are operationally tied to one place - a facility.</p> <p>An asset * always exists * does not change based on time (daily, seasonally, annually, etc) * is NOT reservable on its own * belongs to a parent facility * becomes reservable only when paired with a product that makes it available on specific dates.</p> <p>Assets are the foundation for fixed inventory (physical assets like specific tentpads) and the conceptual anchor for flex inventory (conceptual assets like trail capacity).</p>"},{"location":"datatypes/assets/#assets-vs-inventory","title":"Assets vs Inventory","text":"<p>Asset = the persistent object Inventory = the asset on a specific date</p> <p>Example: - Asset: Tentpad #43 at Rathtrevor Beach - Inventory: Tentpad #43 on 2024\u201108\u201115</p> <p>The tentpad exists all year, but it only becomes reservable as inventory when a product defines - when it is available - how it is governed - how many exist (in flex asset cases)</p> <p>The separation keeps the system clean: assets define what exists, while products/productDates and inventory define when it is reservable and how it behaves.</p> <p>Assets allow the system to: - represent physical infrastructure (campsites, cabins, parking stalls) - represent conceptual capacity (trail day\u2011use slots, backcountry tentpad counts) - attach metadata (location, images, amenities) - supplement map rendering - supplement search and discovery - support future features like asset\u2011level analytics or maintenance tracking</p> <p>Assets are not created or destroyed seasonally \u2014 they persist even when the experience is closed or otherwise unavailable.</p>"},{"location":"datatypes/assets/#example-turning-an-asset-into-inventory","title":"Example: Turning an asset into inventory","text":"<p>A tentpad exists year\u2011round, but the campground is only open May\u2013September. - Asset: Tentpad #43 - Product: \u201cRathtrevor Beach Camping \u2013 Regular Site\u201d - ProductDate: All dates from May 1 to September 30 - Inventory: Tentpad #43 on each of those dates</p> <p>The Product is what \u201cactivates\u201d the asset for a specific season.</p>"},{"location":"datatypes/assets/#properties","title":"Properties","text":""},{"location":"datatypes/assets/#assets_1","title":"Assets","text":"Property Type Description <code>pk</code> String Partition key for the item. Always begins with <code>asset::&lt;collectionId&gt;::&lt;facilityType&gt;::&lt;facilityId&gt;</code>. Groups all assets that belong to a facility. <code>sk</code> String Sort key uniquely identifying the item within the partition. Typically just <code>&lt;assetType&gt;::&lt;assetId&gt;</code> <code>schema</code> String Item datatype/schema. Will always be 'product' for products <code>globalId</code> String UUID used for GSIs and cross\u2011collection lookups. <code>collectionId</code> String Identifier linking the asset to its operational collection (e.g., <code>bcparks_1</code>). <code>facilityType</code> String Parent <code>facilityType</code> <code>facilitySubType</code> String Parent <code>facilitySubType</code>, if available <code>facilityId</code> String Parent <code>facilityId</code> <code>assetType</code> String Type of asset <code>assetId</code> String Identifier uniquely distinguishing this particular asset from other assets of the same type within the same partition <code>identifier</code> Number See <code>assetId</code> <code>displayName</code> String Human\u2011readable name of the item. <code>description</code> String Optional descriptive text explaining the purpose or operational meaning of the item. <code>location</code> OSGeo Asset geospatial centroid <code>minMapZoom</code> Number The smallest zoom level (furthest zoomed out) at which the object will render on a map if it is not in focus <code>maxMapZoom</code> Number The largest zoom level (furthest zoomed in) at which the object will render on a map if it is not in focus <code>imageUrls</code> [String] Array of urls of images of this data item <code>gsipk</code> String GSIPK - for assets, this is the <code>pk</code> of the parent facility <code>gsisk</code> String GSISK - for assets, this is the <code>sk</code> of the parent facility <code>isVisible</code> Boolean Whether or not this item will be returned if it generates a search hit <code>creationDate</code> DateTime Timestamp of when the item was first created <code>lastUpdated</code> DateTime Timestamp of when the item was last updated <code>version</code> Number Data revision number `searchTerms String Comma-separated list of terms OpenSearch can use to link text searches to this data item <code>adminNotes</code> String Administrative notes to describe the data, will never be surfaced to the public <p>Assets may have many properties unique to their <code>assetType</code>. Some examples follow for a campsite <code>assetType</code>:</p> Property Type Description <code>assetGroupIds</code> [String] Future consideration, if assets need further grouping mechanisms beyond what their parent facility and collection allow for <code>siteNumber</code> Number The number of the campsite in the campground <code>siteType</code> String Type of campsite, if differentiation is useful. Examples: \"regular\", \"walk-in\", \"rv\"... <code>hasSani</code> Boolean Whether or not the site has a sanitary hookup <code>hasElec</code> Boolean Whether or not the site has an electrical hookup <code>onCampgroundPerimeter</code> Boolean Whether or not the campsite is on the edge of the campground (typically more popular) <code>onShoreline</code> Boolean Whether or not the campsite is on the edge of a lake, river, the ocean, etc. <code>metersToPotWater</code> Number Distance in meters to nearest source of potable water <code>metersToToilet</code> Number Distance in meters to the nearest toilet <code>metersToShower</code> Number Distance in meters to the nearest shower <code>area</code> Number Square meterage of the site <p>... and many more properties. These can be useful to help users narrow down exactly what they are looking for once they select a campground.</p> <pre><code>{\n  \"pk\": \"asset::bcparks_1::campground::1\",\n  \"sk\": \"tentpad::1\",\n  \"gsi1pk\": \"facility::bcparks_1\",\n  \"gsi1sk\": \"campground::1\",\n  \"schema\": \"asset\",\n  \"globalId\": \"23ertrg4-t54e-tyhr-ghnj-rer4323e543t\",\n  \"collectionId\": \"bcparks_1\",\n  \"facilityType\": \"campground\",\n  \"facilitySubType\": \"\",\n  \"facilityId\": 1,\n  \"assetType\": \"tentpad\",\n  \"assetId\": 1,\n  \"identifier\": 1,\n  \"displayName\": \"Baby Bedwell Lake Campground Tentpad 1\",\n  \"description\": \"Tentpad 1 at Baby Bedwell Lake campground, a designated backcountry camping area on the Bedwell Lake Trail in Strathcona Provincial Park.\",\n  \"location\": {\n    \"type\": \"point\",\n    \"coordinates\": [\n      -125.605,\n      49.505\n    ]\n  },\n  \"imageUrls\": [\n    \"https://...\",\n    \"https://...\"\n  ],\n  \"minMapZoom\": 10,\n  \"maxMapZoom\": 20,\n  \"creationDate\": \"2026-01-06T15:30:00.000Z\",\n  \"lastUpdated\": \"2026-01-06T15:30:00.000Z\",\n  \"version\": 1,\n  \"searchTerms\": \"baby bedwell lake, bedwell lake, strathcona park...\",\n  \"adminNotes\": \"\"\n}\n</code></pre>"},{"location":"datatypes/availability-signals/","title":"AvailabilitySignal","text":"<p>An AvailabilitySignal is a tiny, high\u2011frequency counter that tracks availability on an eventually-consistent basis for a specific ProductDate. If any availability change occurs (inventory is allocated or released), a dirty bit is flipped. On a set cadence, the bit value is checked. If the bit is \"dirty\", it indicates that availability has changed since the last check, and the system can perform a more comprehensive availability check for that ProductDate and store the result. This allows the system to maintain a cache of availability for ProductDates that is updated in near real-time, without needing to perform expensive availability checks on every request. The AvailabilitySignal serves as a lightweight indicator that triggers more thorough checks only when necessary, improving performance while still providing reasonably up-to-date availability information.</p> <p>AvailabilitySignals expire after the date of the ProductDate they are associated with, ensuring that stale availability data is not used indefinitely. When a new ProductDate is seeded, a new AvailabilitySignal is also seeded to start tracking availability changes for that date.</p> <p>Cadence checks are triggered by AWS EventBridge.</p>"},{"location":"datatypes/availability-signals/#availabilitysignal-lifecycle","title":"AvailabilitySignal Lifecycle","text":"<ol> <li>When a new ProductDate is seeded, a corresponding AvailabilitySignal is also seeded. Each AvailabilitySignal is associated with a CadenceBucket that defines how frequently availability checks should occur. The AvailabilitySignal starts with a \"clean\" state, indicating that no availability changes have occurred since the last check.</li> <li>Whenever an availability change occurs for that ProductDate (e.g., inventory is allocated or released), the dirty bit on the AvailabilitySignal must also be flipped to \"dirty\" to indicate that availability has changed.</li> <li>Each CadenceBucket corresponds to an AWS EventBridge rule that triggers availability checks on the defined cadence. When the EventBridge rule triggers, it queries for all AvailabilitySignals in the corresponding CadenceBucket. This query is performed by checking the GSI for pk = CadenceBucket ID, and sk = \"dirty\". For each AvailabilitySignal, it checks the dirty bit. If the bit is \"dirty\", it performs a comprehensive availability check for the associated ProductDate, updates the cached availability value on the AvailabilitySignal, and resets the dirty bit to \"clean\". If the bit is not \"dirty\", it skips the availability check for that ProductDate since no changes have occurred.</li> <li>AvailabilitySignals automatically expire after the date of the ProductDate they are associated with. This is managed by setting an expiry timestamp on the AvailabilitySignal when it is seeded, and a background process can periodically clean up expired signals to prevent stale data from being used.</li> </ol> <p>With this setup, the system can efficiently track availability changes for ProductDates and maintain a cache of availability that is updated in near real-time, while minimizing the performance impact of frequent availability checks.</p>"},{"location":"datatypes/availability-signals/#availabilitysignal-triggered","title":"AvailabilitySignal Triggered","text":"<pre><code>flowchart LR\na[Booking affects availability for a ProductDate] --&gt; b[AvailabilitySignal notified of change]\n</code></pre>"},{"location":"datatypes/availability-signals/#availability-estimation-process-triggered-by-eventbridge-rule","title":"Availability Estimation Process Triggered by EventBridge Rule","text":"<pre><code>flowchart LR\na[EventBridge rule triggers availability estimation process based on CadenceBucket] --&gt; b[System queries AvailabilitySignals linked to CadenceBucket]\nb --&gt; c{Has the AvailabilitySignal changed since the last estimation?}\nc -- No --&gt; d[No availability estimation needed, process ends]\nc -- Yes --&gt; e[System performs availability estimation for affected ProductDates based on the defined AvailabilityEstimationPattern]\ne --&gt; f[System updates the cached availability value on the AvailabilitySignal and resets the dirty bit]\n</code></pre>"},{"location":"datatypes/availability-signals/#properties","title":"Properties","text":""},{"location":"datatypes/availability-signals/#availabilitysignal_1","title":"AvailabilitySignal","text":"property type description derived from evaluated when <code>pk</code> String Partition key \"availabilitySignal::\\::\\::\\::\\\" Inherited from parent ProductDate primary key <code>sk</code> String Sort key \"\\\" Inherited from parent ProductDate primary key <code>gsipk</code> String Global secondary index partition key CadenceBucket ID Querying for all AvailabilitySignals on CadenceBucket interval <code>gsisk</code> String Global secondary index sort key Dirty bit - Flipped when a change to availability occurs CadenceBuckets query only for changed availability <code>schema</code> String Data type/Schema \"availabilitySignal\" Identifying that this item is a \"availabilitySignal\" <code>globalId</code> String Globally unique UUID Automatically generating on AvailabilitySignal seed Searching for this specific item using the <code>globalId</code> GSI <code>value</code> String Cached availability value for the associated ProductDate Automatically updating on availability check Providing a cached availability value that is updated in near real-time based on changes indicated by the <code>counter</code> <code>lastUpdatedAt</code> Timestamp The timestamp of the last cadence check Automatically updating on cadence check Recording when the last availability check was performed <code>availabilityEstimationPattern</code> AvailabilityEstimationPattern Pattern governing how availability is estimated Inherited from parent Product Determining how availability is estimated for ProductDates related to this AvailabilitySignal <code>expiry</code> Timestamp The timestamp when this AvailabilitySignal should be considered expired and deleted Automatically setting on seed Ensuring that stale availability data is not kept <pre><code>{\n  \"pk\": \"availabilitySignal::mockPark1::backcountryCamp::1::1\",\n  \"sk\": \"2026-07-01\",\n  \"schema\": \"availabilitySignal\",\n  \"globalId\": \"c7e8b2c1-5f3a-4e9d-9a2f-8b7e4d2a1f3b\",\n  \"value\": \"high\",\n  \"lastUpdatedAt\": \"2026-06-30T12:00:00.000Z\",\n  \"availabilityEstimationPattern\": {\n    \"estimationMode\": \"exact\",\n    \"cadence\": {\n      \"minutes\": 5\n    }\n  },\n  \"expiry\": \"2026-07-02T00:00:00.000Z\"\n}\n</code></pre>"},{"location":"datatypes/booking-dates/","title":"BookingDate","text":"property type description derived from evaluated when <code>pk</code> String Partition key \"bookingDate::\\\" Constructing the primary key for this BookingDate based on its associated Booking <code>sk</code> String Sort key \"\\\" Constructing the sort key for this BookingDate based on its date <code>gsi1pk</code> String Global secondary index partition key Reserved Reserved <code>gsi1sk</code> String Global secondary index sort key Reserved Reserved <code>schema</code> String Data type/Schema \"bookingDate\" Identifying that this item is a \"bookingDate\" <code>globalId</code> String Globally unique UUID Automatically generating on BookingDate creation Ensuring that each BookingDate has a unique identifier <code>bookingId</code> String The ID of the Booking this BookingDate is associated with Derived from the parent Booking's ID Linking this BookingDate to its parent Booking <code>user</code> String The user sub of the customer who made the Booking Derived from the parent Booking's customer information Associating this BookingDate with the user who made the booking for access control and querying purposes <code>date</code> Date The specific date this BookingDate represents Derived from the reservation details of the Booking Identifying which date this BookingDate corresponds to within the Booking's itinerary <code>inventory</code> [PrimaryKey] The specific inventory items that are reserved for this date Derived from the reservation details of the Booking Specifying which inventory items are allocated for this BookingDate based on the reservations made in the Booking <code>reservationSnapshot</code> BookingDateReservationSnapshot The snapshot of the reservation details for this date at the time of booking Derived from the reservations made in the Booking for this date Capturing the specific reservation details for this date based on the Booking's reservations at the moment it was created <code>reservationValues</code> BookingDateReservationValues The snapshot of the reservation values for this date at the time of booking Derived from the reservations made in the Booking for this date Capturing the specific reservation values for this date based on the Booking's reservations at the moment it was created <code>partyValues</code> BookingDatePartyValues The snapshot of the party composition values for this date at the time of booking Derived from the reservations made in the Booking for this date Capturing the specific party composition values for this date based on the Booking's reservations at the moment it was created <code>feePolicySnapshot</code> BookingDateFeePolicySnapshot The snapshot of the fee policy details for this date at the time of booking Derived from the parent Product's referenced Fee Policy at the time of booking Capturing the specific fee policy details for this date based on the Product's Fee Policy at the moment it was created <code>feeValues</code> BookingDateFeeValues The snapshot of the fee values for this date at the time of booking Derived from the fee policy details and reservation details for this date Capturing the specific fee values for this date based on the fee policy and reservation details at the moment it was created"},{"location":"datatypes/booking-dates/#bookingdatereservationsnapshot","title":"BookingDateReservationSnapshot","text":"property type description derived from evaluated when <code>isDiscoverable</code> Boolean Was the reservation for this date discoverable? Derived from the ProductDate's <code>isDiscoverable</code> value Determining if the reservation for this date was discoverable at the time of booking <code>isReservable</code> Boolean Was the reservation for this date reservable? Derived from the ProductDate's <code>isReservable</code> value Determining if the reservation for this date was reservable at the time of booking <code>minDailyInventory</code> Number What was the minimum daily inventory allowed for this date? Derived from the ProductDate's <code>minDailyInventory</code> value Capturing the minimum daily inventory for this date at the time of booking <code>maxDailyInventory</code> Number What was the maximum daily inventory allowed for this date? Derived from the ProductDate's <code>maxDailyInventory</code> value Capturing the maximum daily inventory for this date at the time of booking <code>temporalAnchors</code> BookingDateResolvedTemporalAnchors What were the temporal anchors for this date? Derived from the ProductDate's <code>temporalWindows</code> values Capturing the temporal anchors for this date at the time of booking <code>temporalWindows</code> BookingDateResolvedTemporalWindows What were the temporal windows for this date? Derived from the ProductDate's <code>temporalWindows</code> values Capturing the temporal windows for this date at the time of booking"},{"location":"datatypes/booking-dates/#bookingdateresolvedtemporalanchors","title":"BookingDateResolvedTemporalAnchors","text":"property type description derived from evaluated when <code>checkInAnchor</code> Timestamp What was the check-in temporal anchor for this date? Derived from the ProductDate's <code>temporalWindows</code> values Capturing the check-in temporal anchor for this date at the time of booking <code>checkOutAnchor</code> Timestamp What was the check-out temporal anchor for this date? Derived from the ProductDate's <code>temporalWindows</code> values Capturing the check-out temporal anchor for this date at the time of booking <code>noShowAnchor</code> Timestamp What was the no-show temporal anchor for this date? Derived from the ProductDate's <code>temporalWindows</code> values Capturing the no-show temporal anchor for this date at the time of booking"},{"location":"datatypes/booking-dates/#bookingdateresolvedtemporalwindows","title":"BookingDateResolvedTemporalWindows","text":"property type description derived from evaluated when <code>discoveryWindow</code> TemporalWindow What was the discovery temporal window for this date? Derived from the ProductDate's <code>temporalWindows.discoveryWindow</code> value Capturing the discovery temporal window for this date at the time of booking <code>reservationWindow</code> TemporalWindow What was the reservation temporal window for this date? Derived from the ProductDate's <code>temporalWindows.reservationWindow</code> value <code>restrictedBookingWindow</code> TemporalWindow What was the restricted booking temporal window for this date? Derived from the ProductDate's <code>temporalWindows.restrictedBookingWindow</code> value Capturing the restricted booking temporal window for this date at the time of booking"},{"location":"datatypes/booking-dates/#bookingdatereservationvalues","title":"BookingDateReservationValues","text":"property type description derived from evaluated when <code>totalInventory</code> Number The inventory count on this date The quantity of inventory items reserved for this date"},{"location":"datatypes/booking-dates/#partyvalues","title":"PartyValues","text":"<p>Note that the party policy and all party composition rules are defined at the Product/Booking level and do not vary day to day, so the BookingDate does not need to capture a party policy snapshot. However, the actual party composition values can vary day to day based on the reservations made in the Booking, so those values are captured here.</p> property type description derived from evaluated when <code>isValid</code> Boolean Is the party composition for this date valid based on the Product's party composition rules? Derived from evaluating the party composition for this date against the Product's party composition rules Determining if the party composition for this date is valid at the time of booking <code>partyComposition</code> BookingDatePartyComposition The specific party composition for this date Derived from the reservations made in the Booking for this date Capturing the specific party composition for this date based on the reservations made in the Booking at the moment it was created"},{"location":"datatypes/booking-dates/#bookingdatepartycomposition","title":"BookingDatePartyComposition","text":"property type description derived from evaluated when <code>id</code> String The identifier for this type of party member or equipment Derived from the Product's party composition rules Identifying the type of party member or equipment based on the Product's party composition rules <code>label</code> String The label for this type of party member or equipment Derived from the Product's party composition rules Providing a human-readable label for this type of party member or equipment based on the Product's party composition rules <code>quantity</code> Number The count of this type of party member or equipment for this date Derived from the reservations made in the Booking for this date Capturing the count of this type of party member or equipment for this date based on the reservations made in the Booking at the moment it was created"},{"location":"datatypes/booking-dates/#bookingdatefeepolicysnapshot","title":"BookingDateFeePolicySnapshot","text":"property type description derived from evaluated when <code>feeSchedule</code> FeeSchedule The fee schedule that applies to this date Derived from the parent Product's referenced Fee Policy at the time of booking Capturing the fee schedule for this date based on the Product's Fee Policy at the moment it was created <code>lineItems</code> LineItem The fee policy line items that apply to this date Derived from the parent Product's referenced Fee Policy at the time of booking Capturing the fee policy line items for this date based on the Product's Fee Policy at the moment it was created"},{"location":"datatypes/booking-dates/#bookingdatefeevalues","title":"BookingDateFeeValues","text":"property type description derived from evaluated when <code>resolvedLineItems</code> ResolvedLineItem The resolved fee line items for this Booking Derived from BookingFeePolicySnapshot and client input on Booking POST Capturing the specific fee line items for this Booking based on the fee policy snapshot and customer input <code>totalDiscounts</code> [ResolvedLineItemDiscount] The total amount of discounts applied to this BookingDate Derived from the resolved line items for this BookingDate Calculating the total discounts for this BookingDate based on the resolved fee line items <code>totalTaxes</code> [ResolvedLineItemTax] The total amount of taxes applied to this BookingDate Derived from the resolved line items for this BookingDate Calculating the total taxes for this BookingDate based on the resolved fee line items <code>subTotal</code> Number The subtotal amount for this BookingDate before taxes Derived from the resolved line items for this BookingDate Calculating the subtotal for this BookingDate based on the resolved fee line items <code>total</code> Number The total amount for this BookingDate after applying taxes and discounts Derived from the resolved line items for this BookingDate Calculating the total for this BookingDate based on the resolved fee line items, including taxes and discounts"},{"location":"datatypes/booking-dates/#example-bookingdate","title":"Example BookingDate","text":""},{"location":"datatypes/booking-dates/#immediately-after-booking-creation-initialization","title":"Immediately after Booking Creation (initialization)","text":"<pre><code>{\n  \"pk\": \"bookingDate::550e8400-e29b-41d4-a716-446655440000\",\n  \"sk\": \"2026-02-09\",\n  \"gsi1pk\": \"user::b7e6c2f2-3a1d-4e8a-9e0d-8c2a1b7e6c2f\",\n  \"gsi1sk\": \"2026-02-09::bookingDate\",\n  \"schema\": \"bookingDate\",\n  \"globalId\": \"c3f1a8e2-7b4d-4c9a-9f2a-8e7b1c3f1a8\",\n  \"bookingId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"userSub\": \"b7e6c2f2-3a1d-4e8a-9e0d-8c2a1b7e6c2f\",\n  \"date\": \"2026-02-09\",\n  \"inventory\": {\n    \"quantity\": 1,\n    \"items\": [\n      {\n        \"pk\": \"inventory::mockPark1::backcountryCamp::1::1::2026-02-09\",\n        \"sk\": \"asset::mockPark1::campground::1::tentPad::6::1\"\n      }\n    ]\n  },\n  \"temporalContext\": {\n    \"discoveryWindow\": {\n      \"open\": \"2026-01-01T07:00:00-08:00\",\n      \"close\": \"2026-12-31T23:59:59-08:00\"\n    },\n    \"reservationWindow\": {\n      \"open\": \"2026-01-26T07:00:00-08:00\",\n      \"close\": \"2026-02-08T23:59:59-08:00\"\n    },\n    \"restrictedBookingWindow\": {\n      \"open\": \"2026-01-26T07:00:00-08:00\",\n      \"close\": \"2026-01-27T07:00:00-08:00\"\n    },\n    \"productDate\": \"2026-02-09\",\n    \"checkInAnchor\": \"2026-02-09T14:00:00-08:00\",\n    \"checkOutAnchor\": \"2026-02-10T11:00:00-08:00\",\n    \"noShowAnchor\": \"2026-02-09T23:59:59-08:00\"\n  },\n  \"reservationPolicySnapshot\": {\n    \"isDiscoverable\": true,\n    \"isReservable\": true,\n    \"minDailyInventory\": 1,\n    \"maxDailyInventory\": 1,\n    \"temporalAnchors\": {\n      \"checkInAnchor\": \"2026-02-09T14:00:00-08:00\",\n      \"checkOutAnchor\": \"2026-02-10T11:00:00-08:00\",\n      \"noShowAnchor\": \"2026-02-09T23:59:59-08:00\"\n    },\n    \"temporalWindows\": {\n      \"discoveryWindow\": {\n        \"open\": \"2026-01-01T07:00:00-08:00\",\n        \"close\": \"2026-12-31T23:59:59-08:00\"\n      },\n      \"reservationWindow\": {\n        \"open\": \"2026-01-26T07:00:00-08:00\",\n        \"close\": \"2026-02-08T23:59:59-08:00\"\n      },\n      \"restrictedBookingWindow\": {\n        \"open\": \"2026-01-26T07:00:00-08:00\",\n        \"close\": \"2026-01-27T07:00:00-08:00\"\n      }\n    }\n  },\n  \"partyContext\": {\n    \"isValid\": false,\n    \"partyComposition\": [\n      {\n        \"id\": \"adults\",\n        \"label\": \"Adults (18+)\",\n        \"quantity\": 0\n      },\n      {\n        \"id\": \"children\",\n        \"label\": \"Children &lt;18\",\n        \"quantity\": 0\n      },\n      {\n        \"id\": \"tents\",\n        \"label\": \"Tents\",\n        \"quantity\": 0\n      }\n    ]\n  },\n  \"feePolicySnapshot\": {\n    \"feeSchedule\": [\n      {\n        \"id\": \"costPerAdult\",\n        \"label\": \"Adult Nightly Fee\",\n        \"type\": \"unit\",\n        \"amount\": 10\n      },\n      {\n        \"id\": \"costPerChild\",\n        \"label\": \"Child Nightly Fee\",\n        \"type\": \"unit\",\n        \"amount\": 5\n      },\n      {\n        \"id\": \"costPerTent\",\n        \"label\": \"Tent Nightly Fee\",\n        \"type\": \"unit\",\n        \"amount\": 15\n      },\n      {\n        \"id\": \"tax\",\n        \"label\": \"Tax\",\n        \"type\": \"percentage\",\n        \"amount\": 0.05\n      }\n    ],\n    \"lineItems\": [\n      {\n        \"id\": \"adultLineItem\",\n        \"label\": \"Adult Fee\",\n        \"type\": \"unit\",\n        \"if\": [],\n        \"quantity\": {\n          \"type\": \"ref\",\n          \"value\": \"partyContext.adults\"\n        },\n        \"rate\": {\n          \"type\": \"ref\",\n          \"value\": \"feeSchedule.costPerAdult\"\n        },\n        \"taxApplied\": [\n          {\n            \"type\": \"ref\",\n            \"value\": \"feeSchedule.tax\"\n          }\n        ],\n        \"discountsApplied\": [],\n        \"isReturnable\": true\n      },\n      {\n        \"id\": \"childLineItem\",\n        \"label\": \"Child Fee\",\n        \"type\": \"unit\",\n        \"if\": [],\n        \"quantity\": {\n          \"type\": \"ref\",\n          \"value\": \"partyContext.children\"\n        },\n        \"rate\": {\n          \"type\": \"ref\",\n          \"value\": \"feeSchedule.costPerChild\"\n        },\n        \"taxApplied\": [\n          {\n            \"type\": \"ref\",\n            \"value\": \"feeSchedule.tax\"\n          }\n        ],\n        \"discountsApplied\": [],\n        \"isReturnable\": true\n      },\n      {\n        \"id\": \"tentLineItem\",\n        \"label\": \"Tent Fee\",\n        \"type\": \"unit\",\n        \"if\": [],\n        \"quantity\": {\n          \"type\": \"ref\",\n          \"value\": \"inventory.quantity\"\n        },\n        \"rate\": {\n          \"type\": \"ref\",\n          \"value\": \"feeSchedule.costPerTent\"\n        },\n        \"taxApplied\": [\n          {\n            \"type\": \"ref\",\n            \"value\": \"feeSchedule.tax\"\n          }\n        ],\n        \"discountsApplied\": [],\n        \"isReturnable\": true\n      }\n    ]\n  },\n  \"feeValues\": {\n    \"resolvedLineItems\": [\n      {\n        \"id\": \"adultFeeLine\",\n        \"label\": \"Adult Fee\",\n        \"type\": \"unit\",\n        \"isReturnable\": true,\n        \"units\": [],\n        \"lineDiscounts\": [],\n        \"lineTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 0\n          }\n        ],\n        \"lineSubTotal\": 0,\n        \"lineTotal\": 0\n      },\n      {\n        \"id\": \"childFeeLine\",\n        \"label\": \"Child Fee\",\n        \"type\": \"unit\",\n        \"isReturnable\": true,\n        \"units\": [],\n        \"lineDiscounts\": [],\n        \"lineTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 0\n          }\n        ],\n        \"lineSubTotal\": 0,\n        \"lineTotal\": 0\n      },\n      {\n        \"id\": \"tentFeeLine\",\n        \"label\": \"Tent Fee\",\n        \"type\": \"unit\",\n        \"isReturnable\": true,\n        \"units\": [],\n        \"lineDiscounts\": [],\n        \"lineTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 0\n          }\n        ],\n        \"lineSubTotal\": 0,\n        \"lineTotal\": 0\n      }\n    ],\n    \"totalDiscounts\": [],\n    \"totalTaxes\": [\n      {\n        \"id\": \"tax\",\n        \"rate\": 0.05,\n        \"amount\": 0\n      }\n    ],\n    \"subTotal\": 0,\n    \"total\": 0\n  }\n}\n</code></pre>"},{"location":"datatypes/booking-dates/#after-booking-finalization","title":"After Booking Finalization","text":"<pre><code>{\n  \"pk\": \"bookingDate::550e8400-e29b-41d4-a716-446655440000\",\n  \"sk\": \"2026-02-09\",\n  \"gsi1pk\": \"\",\n  \"gsi1sk\": \"\",\n  \"schema\": \"bookingDate\",\n  \"globalId\": \"c3f1a8e2-7b4d-4c9a-9f2a-8e7b1c3f1a8\",\n  \"bookingId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"user\": \"b7e6c2f2-3a1d-4e8a-9e0d-8c2a1b7e6c2f\",\n  \"date\": \"2026-02-09\",\n  \"inventory\": {\n    \"quantity\": 1,\n    \"items\": [\n      {\n        \"pk\": \"inventory::mockPark1::backcountryCamp::1::1::2026-02-09\",\n        \"sk\": \"asset::mockPark1::campground::1::tentPad::6::1\"\n      }\n    ]\n  },\n  \"reservationPolicySnapshot\": {\n    \"isDiscoverable\": true,\n    \"isReservable\": true,\n    \"minDailyInventory\": 1,\n    \"maxDailyInventory\": 1,\n    \"temporalAnchors\": {\n      \"checkInAnchor\": \"2026-02-09T14:00:00-08:00\",\n      \"checkOutAnchor\": \"2026-02-10T11:00:00-08:00\",\n      \"noShowAnchor\": \"2026-02-09T23:59:59-08:00\"\n    },\n    \"temporalWindows\": {\n      \"discoveryWindow\": {\n        \"open\": \"2026-01-01T07:00:00-08:00\",\n        \"close\": \"2026-12-31T23:59:59-08:00\"\n      },\n      \"reservationWindow\": {\n        \"open\": \"2026-01-26T07:00:00-08:00\",\n        \"close\": \"2026-02-08T23:59:59-08:00\"\n      },\n      \"restrictedBookingWindow\": {\n        \"open\": \"2026-01-26T07:00:00-08:00\",\n        \"close\": \"2026-01-27T07:00:00-08:00\"\n      }\n    }\n  },\n  \"partyContext\": {\n    \"isValid\": true,\n    \"partyComposition\": [\n      {\n        \"id\": \"adults\",\n        \"label\": \"Adults (18+)\",\n        \"quantity\": 2\n      },\n      {\n        \"id\": \"children\",\n        \"label\": \"Children &lt;18\",\n        \"quantity\": 1\n      },\n      {\n        \"id\": \"tents\",\n        \"label\": \"Tents\",\n        \"quantity\": 1\n      }\n    ]\n  },\n  \"feePolicySnapshot\": {\n    \"feeSchedule\": [\n      {\n        \"id\": \"costPerAdult\",\n        \"label\": \"Adult Nightly Fee\",\n        \"type\": \"unit\",\n        \"amount\": 10\n      },\n      {\n        \"id\": \"costPerChild\",\n        \"label\": \"Child Nightly Fee\",\n        \"type\": \"unit\",\n        \"amount\": 5\n      },\n      {\n        \"id\": \"costPerTent\",\n        \"label\": \"Tent Nightly Fee\",\n        \"type\": \"unit\",\n        \"amount\": 15\n      },\n      {\n        \"id\": \"tax\",\n        \"label\": \"Tax\",\n        \"type\": \"percentage\",\n        \"amount\": 0.05\n      }\n    ],\n    \"lineItems\": [\n      {\n        \"id\": \"adultLineItem\",\n        \"label\": \"Adult Fee\",\n        \"type\": \"unit\",\n        \"if\": [],\n        \"quantity\": {\n          \"type\": \"ref\",\n          \"value\": \"partyContext.adults\"\n        },\n        \"rate\": {\n          \"type\": \"ref\",\n          \"value\": \"feeSchedule.costPerAdult\"\n        },\n        \"taxApplied\": [\n          {\n            \"type\": \"ref\",\n            \"value\": \"feeSchedule.tax\"\n          }\n        ],\n        \"discountsApplied\": [],\n        \"isReturnable\": true\n      },\n      {\n        \"id\": \"childLineItem\",\n        \"label\": \"Child Fee\",\n        \"type\": \"unit\",\n        \"if\": [],\n        \"quantity\": {\n          \"type\": \"ref\",\n          \"value\": \"partyContext.children\"\n        },\n        \"rate\": {\n          \"type\": \"ref\",\n          \"value\": \"feeSchedule.costPerChild\"\n        },\n        \"taxApplied\": [\n          {\n            \"type\": \"ref\",\n            \"value\": \"feeSchedule.tax\"\n          }\n        ],\n        \"discountsApplied\": [],\n        \"isReturnable\": true\n      },\n      {\n        \"id\": \"tentLineItem\",\n        \"label\": \"Tent Fee\",\n        \"type\": \"unit\",\n        \"if\": [],\n        \"quantity\": {\n          \"type\": \"ref\",\n          \"value\": \"partyContext.tents\"\n        },\n        \"rate\": {\n          \"type\": \"ref\",\n          \"value\": \"feeSchedule.costPerTent\"\n        },\n        \"taxApplied\": [\n          {\n            \"type\": \"ref\",\n            \"value\": \"feeSchedule.tax\"\n          }\n        ],\n        \"discountsApplied\": [],\n        \"isReturnable\": true\n      }\n    ]\n  },\n  \"feeValues\": {\n    \"resolvedLineItems\": [\n      {\n        \"id\": \"adultFeeLine\",\n        \"label\": \"Adult Fee\",\n        \"type\": \"unit\",\n        \"isReturnable\": true,\n        \"units\": [\n          {\n            \"rate\": 10,\n            \"discountsApplied\": [],\n            \"taxApplied\": [\n              {\n                \"id\": \"tax\",\n                \"rate\": 0.05,\n                \"amount\": 0.50\n              }\n            ],\n            \"unitSubTotal\": 10,\n            \"unitTotal\": 10.50\n          },\n          {\n            \"rate\": 10,\n            \"discountsApplied\": [],\n            \"taxApplied\": [\n              {\n                \"id\": \"tax\",\n                \"rate\": 0.05,\n                \"amount\": 0.50\n              }\n            ],\n            \"unitSubTotal\": 10,\n            \"unitTotal\": 10.50\n          }\n        ],\n        \"lineDiscounts\": [],\n        \"lineTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 1.00\n          }\n        ],\n        \"lineSubTotal\": 20,\n        \"lineTotal\": 21\n      },\n      {\n        \"id\": \"childFeeLine\",\n        \"label\": \"Child Fee\",\n        \"type\": \"unit\",\n        \"isReturnable\": true,\n        \"units\": [\n          {\n            \"rate\": 5,\n            \"discountsApplied\": [],\n            \"taxApplied\": [\n              {\n                \"id\": \"tax\",\n                \"rate\": 0.05,\n                \"amount\": 0.25\n              }\n            ],\n            \"unitSubTotal\": 5,\n            \"unitTotal\": 5.25\n          }\n        ],\n        \"lineDiscounts\": [],\n        \"lineTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 0.25\n          }\n        ],\n        \"lineSubTotal\": 5,\n        \"lineTotal\": 5.25\n      },\n      {\n        \"id\": \"tentFeeLine\",\n        \"label\": \"Tent Fee\",\n        \"type\": \"unit\",\n        \"isReturnable\": true,\n        \"units\": [\n          {\n            \"rate\": 15,\n            \"discountsApplied\": [],\n            \"taxApplied\": [\n              {\n                \"id\": \"tax\",\n                \"rate\": 0.05,\n                \"amount\": 0.75\n              }\n            ],\n            \"unitSubTotal\": 15,\n            \"unitTotal\": 15.75\n          }\n        ],\n        \"lineDiscounts\": [],\n        \"lineTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 0.75\n          }\n        ],\n        \"lineSubTotal\": 15,\n        \"lineTotal\": 15.75\n      }\n    ],\n    \"totalDiscounts\": [],\n    \"totalTaxes\": [\n      {\n        \"id\": \"tax\",\n        \"rate\": 0.05,\n        \"amount\": 2.00\n      }\n    ],\n    \"subTotal\": 40,\n    \"total\": 42\n  }\n}\n</code></pre>"},{"location":"datatypes/bookings/","title":"Booking","text":"<p>A Booking is a concept that limits/enforces valid groupings of inventory that can be purchased together at the same time. They are the authoritative record of a customer committing to a specific Product, capturing the exact Inventory consumed, the policy snapshots applied, and the operational state of the reservation at the moment it was created. They are the ledger entry that ties together customer intent, product configuration, Inventory allocation, and pricing logic, forming the durable truth the rest of the system reacts to.</p> <p>A Booking exists as an isolated, self-contained unit because the system must be able to reason about its contents deterministically. It represents the valid range of inventory groupings that can be purchased together under a single, coherent set of policies. Just as Inventory is the atomic unit of availability, a Booking is the atomic unit of reservation, though the rules around what constitutes a Booking vary much more broadly than Inventory.</p> <p>Similar to how ProductDates are the date-specific execution of Products, Bookings too have date-specific instances called BookingDates. Each BookingDate corresponds to a specific date within the overall Booking period, allowing the system to track and manage availability and allocations on a per-day basis. This design enables the system to handle complex scenarios like multi-day bookings, partial cancellations, and date-specific adjustments while maintaining a clear and consistent record of the booking history. Each BookingDate is associated with the relevant ProductDate and Inventory units for that date, ensuring that all changes to the booking are accurately reflected in the system's state and availability calculations.</p>"},{"location":"datatypes/bookings/#properties","title":"Properties","text":""},{"location":"datatypes/bookings/#booking_1","title":"Booking","text":"property type description derived from evaluated when <code>pk</code> String Partition key booking::<code>collectionId</code>:: <code>activityType</code>::<code>activityId</code>:: <code>productId</code> Searching for all Bookings related to a specific Product. <code>sk</code> String Sort key <code>arrivalDate</code>::<code>bookingId</code> Searching for a specific Booking related to a specific Product (disambiguated by bookingId) <code>gsipk</code> String Global secondary index partition key <code>userSub</code> Querying for all Bookings made by a specific customer <code>gsisk</code> String Global secondary index sort key <code>arrivalDate</code> Sorting a customer's Bookings by arrival date <code>schema</code> String Data type/Schema \"booking\" Identifying that this item is a \"booking\" <code>globalId</code> String Globally unique UUID Automatically generating on Booking POST Searching for this specific item using the <code>globalId</code> GSI <code>collectionId</code> String The identifier of the collection this Booking belongs to Parent Product's <code>collectionId</code> Determining which collection this Booking belongs to <code>activityType</code> String The type of activity this Booking is for Parent Product's <code>activityType</code> Determining what type of Activity this Booking is for <code>activitySubType?</code> String A further categorization of the type of Activity this Booking is for, if available Parent Product's <code>activitySubType</code> Determining what type of <code>activitySubType</code> this Booking is for <code>activityId</code> Number The unique identifier of the parent Activity Parent Product's <code>activityId</code> Determining which specific Activity of <code>activityType</code> within the <code>collectionId</code> that this Booking refers to <code>productId</code> Number The unique identifier of the parent Product Parent Product's <code>productId</code> Determining which specific Product this Booking refers to <code>bookingId</code> String Unique identifier for this Booking (distinct from <code>globalId</code> for traceability purposes) Automatically generating on Booking POST Distinguishing this Booking from other Bookings related to the same Product <code>userSub</code> String The unique identifier of the customer who made the booking Provided by client on Booking POST Associating this Booking with the customer who made it <code>status</code> String The current status of the booking (e.g., \"held\". \"pending\", \"completed\", \"cancelled\") Automatically setting on Booking POST and updating on status changes Tracking the lifecycle state of the booking <code>timezone</code> String IANA timezone identifier for the location where this Booking is reserved Inherited from parent Product Ensuring that all date and time calculations related to this Booking are performed in the correct timezone context <code>asset</code> AssetRef The asset allocated through this Booking Derived from parent Product's assetList and Inventory allocation Tracking which specific asset is allocated through this Booking <code>itineraryRulesSnapshot</code> ItineraryRules The snapshot of the itinerary rules applied to this Booking at the time of booking Derived from parent Product's Itinerary Rules at the time of booking Capturing the itinerary rules context for this Booking at the moment it was created <code>itinerary?</code> ResolvedItinerary The resolved itinerary for this Booking, if applicable Derived from parent Product's Itinerary Rules and the customer's requested itinerary at the time of booking Capturing the specific itinerary for this Booking if the Product has itinerary rules that require resolution at the time of booking <code>reservationPolicySnapshot</code> BookingReservationPolicSnapshot The snapshot of the reservation policy applied to this Booking at the time of booking Derived from parent Product's Reservation Policy at the time of booking Capturing the reservation policy context for this Booking at the moment it was created <code>reservationValues</code> BookingReservationValues The resolved reservation values of this Booking Derived from parent Product's Reservation Policy and client input on Booking POST Capturing the specific reservation values for this Booking based on the Product's Reservation Policy and customer input <code>partyPolicySnapshot</code> BookingPartyPolicySnapshot The snapshot of the party policy applied to this Booking at the time of booking Derived from parent Product's Party Policy at the time of booking Capturing the party policy context for this Booking at the moment it was created <code>partyValues</code> BookingPartyValues The resolved party composition values of this Booking Derived from parent Product's Party Policy and client input on Booking POST Capturing the specific party composition for this Booking based on the Product's Party Policy and customer input <code>feePolicySnapshot</code> ProductFeePolicyReference The snapshot of the fee policy applied to this Booking at the time of booking Derived from parent Product's referenced Fee Policy at the time of booking Capturing the fee policy context for this Booking at the moment it was created <code>feeValues</code> BookingFeeValues The resolved fee values of this Booking Derived from parent Product's Fee Policy and client input on Booking POST Capturing the specific fee values for this Booking based on the Product's Fee Policy and customer input <code>changePolicySnapshot</code> ProductChangePolicyRef The snapshot of the change policy applied to this Booking at the time of booking Derived from parent Product's referenced Change Policy at the time of booking Capturing the change policy context for this Booking at the moment it was created <code>bookingDates</code> [PrimaryKey] List of primary keys of the BookingDates associated with this Booking Automatically generating on Booking POST based on the date range of the booking Tracking the specific BookingDates that are part of this Booking"},{"location":"datatypes/bookings/#bookingtemporalwindows","title":"BookingTemporalWindows","text":"property type description derived from evaluated when <code>changeWindow</code> ResolvedTemporalWindow The change window for this Booking. Derived from parent Product's Reservation Policy Enforcing the change window for this Booking <code>cancellationWindow</code> ResolvedTemporalWindow The cancellation window for this Booking. Derived from parent Product's Reservation Policy Enforcing the cancellation window for this Booking"},{"location":"datatypes/bookings/#resolveditinerary","title":"ResolvedItinerary","text":"property type description derived from evaluated when <code>entryPoint?</code> ResolvedItineraryPoint The resolved entry point for this Booking, if applicable Derived from parent Product's Itinerary Rules and the customer's requested itinerary at the time of booking Capturing the specific entry point for this Booking if the Product has itinerary rules that require resolution at the time of booking <code>exitPoint?</code> ResolvedItineraryPoint The resolved exit point for this Booking, if applicable Derived from parent Product's Itinerary Rules and the customer's requested itinerary at the time of booking Capturing the specific exit point for this Booking if the Product has itinerary rules that require resolution at the time of booking <code>stayPoints?</code> [ResolvedItineraryPoint] The resolved stay points for this Booking, if applicable Derived from parent Product's Itinerary Rules and the customer's requested itinerary at the time of booking Capturing the specific stay points for this Booking if the Product has itinerary rules that require resolution at the time of booking"},{"location":"datatypes/bookings/#resolveditinerarypoint","title":"ResolvedItineraryPoint","text":"property type description derived from evaluated when <code>primaryKey</code> PrimaryKey The primary key of the referenced Access Point or Overnight Stay point Derived from parent Product's Itinerary Rules and the customer's requested itinerary at the time of booking Identifying which specific Access Point or Overnight Stay this itinerary point refers to <code>date</code> Date The date of this itinerary point Derived from the customer's requested itinerary at the time of booking Capturing the specific date for this itinerary point <code>displayName</code> String The display name of this itinerary point Derived from the referenced Access Point or Overnight Stay point Providing a human-readable name for this itinerary point"},{"location":"datatypes/bookings/#bookingreservationpolicysnapshot","title":"BookingReservationPolicySnapshot","text":"property type description derived from evaluated when <code>isDiscoverable</code> Boolean Whether this Booking was discoverable for reservation searches. Parent Product Determining if this Product appears in reservation search results <code>isReservable</code> Boolean Whether this Booking was able to be reserved. Parent Product Determining if this Product can be reserved <code>minTotalDays</code> Number Minimum total days this Booking must span Parent Product Enforcing minimum total days for reservations of this Booking <code>maxTotalDays</code> Number Maximum total days this Booking can span Parent Product Enforcing maximum total days for reservations of this Booking <code>holdDuration</code> Duration The length of time that this Booking can be held in a cart before it expires Parent Product Enforcing cart duration for reservations of this Booking <code>temporalAnchors</code> BookingTemporalAnchors The temporal anchors that define key time points for reservation rules on this Booking. Parent Product Determining the reference points for time-based reservation rules for this Booking. <code>temporalWindows</code> ProductReservationTemporalWindows Temporal windows that governed reservation availability for this Booking Parent Product Enforcing temporal windows for reservations of this Booking"},{"location":"datatypes/bookings/#bookingreservationvalues","title":"BookingReservationValues","text":"property type description derived from evaluated when <code>totalDays</code> Number The total number of days for this Booking Derived from the arrival and departure dates of this Booking Calculating the total days for this Booking to enforce reservation policies that depend on total length of stay <code>restrictedBookingTriggered</code> Boolean Whether this Booking has triggered any restricted booking windows based on its temporal anchors Derived from the temporal anchors of this Booking and the reservation policy rules that define restricted booking windows Determining if this Booking falls within any restricted booking windows that would disallow changes to the booking <code>temporalAnchors</code> <code>BookingTemporalAnchors</code> The resolved temporal anchors for this Booking Derived from the Booking's temporal anchors and the specific reservation policy rules that require resolution at the time of booking Providing the specific temporal anchor values needed to enforce reservation policies for this Booking"},{"location":"datatypes/bookings/#bookingtemporalanchors","title":"BookingTemporalAnchors","text":"property type description derived from evaluated when <code>reservationTime</code> Timestamp The reservation time anchor for this Booking Derived from client input on Booking POST Establishing the reservation time context for this Booking <code>holdExpiryTime</code> Timestamp The hold expiry time anchor for this Booking Derived from client input on Booking POST and updated if the booking hold is extended Establishing the hold expiry time context for this Booking <code>completionTime?</code> Timestamp The completion time anchor for this Booking Derived from client input on Booking POST and updated when the booking is finalized Establishing the completion time context for this Booking <code>arrivalDate</code> Date The arrival date anchor for this Booking Derived from client input on Booking POST Establishing the arrival date context for this Booking <code>departureDate</code> Date The departure date anchor for this Booking Derived from client input on Booking POST Establishing the departure date context for this Booking <code>checkInAfter</code> Timestamp The check-in after time anchor for this Booking Derived from client input on Booking POST Establishing the check-in after time context for this Booking <code>checkOutBefore</code> Timestamp The check-out before time anchor for this Booking Derived from client input on Booking POST Establishing the check-out before time context for this Booking <code>noShowAfter</code> Timestamp The no-show after time anchor for this Booking Derived from client input on Booking POST Establishing the no-show after time context for this Booking"},{"location":"datatypes/bookings/#bookingpartypolicysnapshot","title":"BookingPartyPolicySnapshot","text":"property type description derived from evaluated when <code>partyCategories</code> [PartyCategory] The snapshot of the party category rules applied to this Booking at the time of booking Derived from parent Product's Party Policy at the time of booking Capturing the specific party category rules for this Booking based on the Product's Party Policy at the moment it was created <code>partyCompositionRules</code> [ElegibilityPrimitive] The snapshot of the party composition rules applied to this Booking at the time of booking Derived from parent Product's Party Policy at the time of booking Capturing the specific party composition rules for this Booking based on the Product's Party Policy at the moment it was created"},{"location":"datatypes/bookings/#bookingpartyvalues","title":"BookingPartyValues","text":"property type description derived from evaluated when <code>partyComposition</code> PartyCompositionUnit The resolved party composition for this Booking Derived from parent Product's Party Policy and client input on Booking POST Capturing the specific party composition for this Booking based on the Product's Party Policy and customer input"},{"location":"datatypes/bookings/#partycompositionunit","title":"PartyCompositionUnit","text":"property type description derived from evaluated when <code>id</code> String The unique identifier for this party composition unit Derived from BookingPartyPolicySnapshot Identifying this specific party composition unit <code>label</code> String The display name for this party composition unit Derived from BookingPartyPolicySnapshot Providing a human-readable name for this party composition unit <code>count</code> Number The number of party members/equipment included in this booking for this unit Derived from client input on Booking POST Capturing the specific count for this party composition unit in this Booking"},{"location":"datatypes/bookings/#bookingfeepolicysnapshot","title":"BookingFeePolicySnapshot","text":"property type description derived from evaluated when <code>feeSchedule</code> FeeSchedule The snapshot of the fee schedule applied to this Booking at the time of booking Derived from parent Product's referenced Fee Policy at the time of booking Capturing the specific fee schedule for this Booking based on the Product's Fee Policy at the moment it was created <code>lineItems</code> LineItem The snapshot of the fee line items applied to this Booking at the time of booking Derived from parent Product's referenced Fee Policy and client input on Booking POST at the time of booking Capturing the specific fee line items for this Booking based on the Product's Fee Policy and customer input at the moment it was created"},{"location":"datatypes/bookings/#bookingfeevalues","title":"BookingFeeValues","text":"property type description derived from evaluated when <code>bookingDateTotals</code> BookingDateFeeTotal The breakdown of fee totals for each BookingDate within this Booking Derived from BookingFeePolicySnapshot and client input on Booking POST Calculating the fee totals for each BookingDate within this Booking based on the fee schedule, line items, and customer input <code>resolvedLineItems</code> ResolvedLineItem The resolved fee line items for this Booking Derived from BookingFeePolicySnapshot and client input on Booking POST Capturing the specific fee line items for this Booking based on the fee policy snapshot and customer input <code>bookingDiscounts</code> ResolvedLineItemDiscount The total discount amount for this Booking Derived from the discounts applied to the resolved line items for this Booking Calculating the total discount for this Booking based on the discounts applied to the resolved line items <code>bookingTaxes</code> ResolvedLineItemTax The total tax amount for this Booking Derived from the taxes applied to the resolved line items for this Booking Calculating the total tax for this Booking based on the taxes applied to the resolved line items <code>bookingSubTotal</code> Number The subtotal fee amount for this Booking before taxes and discounts Derived from BookingFeePolicySnapshot and client input on Booking POST Calculating the subtotal fee for this Booking based on the fee schedule, line items, and customer input <code>bookingTotal</code> Number The grand total fee amount for this Booking Derived from BookingFeePolicySnapshot and client input on Booking POST Calculating the grand total fee for this Booking based on the fee schedule, line items, and customer input"},{"location":"datatypes/bookings/#bookingdatefeetotal","title":"BookingDateFeeTotal","text":"property type description derived from evaluated when <code>date</code> Date The date for this BookingDate fee total Derived from the specific BookingDate this fee total corresponds to Identifying which BookingDate this fee total corresponds to <code>total</code> Number The total fee amount for this BookingDate Derived from the fee schedule, line items, and customer input for this specific date Calculating the total fee for this BookingDate based on the fee policy and customer input"},{"location":"datatypes/bookings/#resolvedlineitem","title":"ResolvedLineItem","text":"property type description derived from evaluated when <code>id</code> String The unique identifier for this resolved line item Derived from BookingFeePolicySnapshot and client input on Booking POST Identifying this specific resolved line item <code>label</code> String The display name for this resolved line item Derived from BookingFeePolicySnapshot and client input on Booking POST Providing a human-readable name for this resolved line item <code>type</code> String The type of this resolved line item (e.g., \"flat\", \"unit\") Derived from BookingFeePolicySnapshot and client input on Booking POST Determining how this resolved line item is processed in the overall fee calculation <code>isReturnable</code> Boolean Whether this resolved line item is returnable/refundable Derived from BookingFeePolicySnapshot and client input on Booking POST Determining if this resolved line item can be refunded in the case of a cancellation or change <code>units</code> [ResolvedLineItemUnitBreakdown] The breakdown of units for this resolved line item, if applicable Derived from BookingFeePolicySnapshot and client input on Booking POST Providing a detailed breakdown of units for this resolved line item if it is of type \"unit\" <code>lineTaxes</code> [ResolvedLineItemTax] The breakdown of taxes for this resolved line item, if applicable Derived from BookingFeePolicySnapshot and client input on Booking POST Providing a detailed breakdown of taxes for this resolved line item if it is taxable <code>lineDiscounts</code> [ResolvedLineItemDiscount] The breakdown of discounts for this resolved line item, if applicable Derived from BookingFeePolicySnapshot and client input on Booking POST Providing a detailed breakdown of discounts for this resolved line item if it is discountable <code>lineSubtotal</code> Number The subtotal amount for this line item before taxes and discounts Derived from the quantity, rate, and type of this resolved line item Calculating the subtotal for this line item based on its quantity, rate, and type <code>lineTotal</code> Number The total amount for this line item after applying taxes and discounts Derived from the line subtotal, taxes, and discounts for this resolved line item Calculating the total for this line item based on its subtotal, taxes, and discounts"},{"location":"datatypes/bookings/#resolvedlineitemunitbreakdown","title":"ResolvedLineItemUnitBreakdown","text":"property type description derived from evaluated when <code>rate</code> Number The rate for this unit breakdown Derived from BookingFeePolicySnapshot and client input on Booking POST Determining the rate for this unit breakdown of the resolved line item <code>discountApplied</code> [ResolvedLineItemDiscount] The discount applied to this unit breakdown, if applicable Derived from BookingFeePolicySnapshot and client input on Booking POST Determining the discount applied to this unit breakdown of the resolved line item if it is discountable <code>unitSubTotal</code> Number The subtotal amount for this unit breakdown before taxes Derived from the rate for this unit breakdown Calculating the subtotal for this unit breakdown based on its rate <code>taxApplied</code> [ResolvedLineItemTax] The tax applied to this unit breakdown, if applicable Derived from BookingFeePolicySnapshot and client input on Booking POST Determining the tax applied to this unit breakdown of the resolved line item if it is taxable <code>unitSubTotal</code> Number The subtotal amount for this unit breakdown before taxes Derived from the rate for this unit breakdown Calculating the subtotal for this unit breakdown based on its rate <code>unitTotal</code> Number The total amount for this unit breakdown after applying taxes and discounts Derived from the rate, tax, and discount for this unit breakdown Calculating the total for this unit breakdown based on its rate, tax, and discount"},{"location":"datatypes/bookings/#resolvedlineitemtax","title":"ResolvedLineItemTax","text":"property type description derived from evaluated when <code>id</code> String The unique identifier for this resolved line item tax Derived from BookingFeePolicySnapshot and client input on Booking POST Identifying this specific resolved line item tax <code>rate</code> Number The tax rate for this resolved line item tax Derived from BookingFeePolicySnapshot and client input on Booking POST Determining the tax rate for this resolved line item tax <code>amount</code> Number The tax amount for this resolved line item tax Derived from the line subtotal and tax rate for this resolved line item tax Calculating the tax amount for this resolved line item tax based on the line subtotal and tax rate"},{"location":"datatypes/bookings/#resolvedlineitemdiscount","title":"ResolvedLineItemDiscount","text":"property type description derived from evaluated when <code>id</code> String The unique identifier for this resolved line item discount Derived from BookingFeePolicySnapshot and client input on Booking POST Identifying this specific resolved line item discount <code>rate?</code> Number The discount rate for this resolved line item discount Derived from BookingFeePolicySnapshot and client input on Booking POST Determining the discount rate for this resolved line item discount <code>amount</code> Number The discount amount for this resolved line item discount Derived from the line subtotal and discount rate for this resolved line item discount Calculating the discount amount for this resolved line item discount based on the line subtotal and discount rate"},{"location":"datatypes/bookings/#changepolicysnapshot","title":"ChangePolicySnapshot","text":"property type description derived from evaluated when <code>rules</code> [ChangePolicyRule] The snapshot of the change policy rules applied to this Booking at the time of booking Derived from parent Product's referenced Change Policy at the time of booking Capturing the specific change policy rules for this Booking based on the Product's Change Policy at the moment it was created"},{"location":"datatypes/bookings/#example-booking","title":"Example Booking","text":""},{"location":"datatypes/bookings/#immediately-after-initialization","title":"Immediately after initialization","text":"<pre><code>{\n  \"pk\": \"booking::mockPark1::backcountryCamp::1::1\",\n  \"sk\": \"2026-02-09::550e8400-e29b-41d4-a716-446655440000\",\n  \"gsi1pk\": \"user::b7e6c2f2-3a1d-4e8a-9e0d-8c2a1b7e6c2f\",\n  \"gsi1sk\": \"2026-02-09::booking\",\n  \"schema\": \"booking\",\n  \"globalId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"collectionId\": \"mockPark1\",\n  \"activityType\": \"backcountryCamp\",\n  \"activitySubType\": null,\n  \"activityId\": \"1\",\n  \"productId\": \"1\",\n  \"bookingId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"userSub\": \"b7e6c2f2-3a1d-4e8a-9e0d-8c2a1b7e6c2f\",\n  \"status\": \"held\",\n  \"timezone\": \"America/Vancouver\",\n  \"asset\": {\n    \"primaryKey\": {\n      \"pk\": \"asset::mockPark1::campground::1\",\n      \"sk\": \"campsite::1\"\n    },\n    \"allocationType\": \"fixed\",\n    \"quantity\": 1\n  },\n  \"itineraryRulesSnapshot\": {\n    \"entryExit\": {\n      \"required\": true,\n      \"allowedEntryPoints\": [\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::1\"\n        },\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::2\"\n        }\n      ],\n      \"allowedExitPoints\": [\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::1\"\n        },\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::2\"\n        }\n      ]\n    },\n    \"stayPoints\": {\n      \"required\": true,\n      \"allowedStayPoints\": [\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"campground::1\"\n        },\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"campground::2\"\n        }\n      ]\n    }\n  },\n  \"itinerary\": {},\n  \"reservationPolicySnapshot\": {\n    \"isDiscoverable\": true,\n    \"isReservable\": true,\n    \"minTotalDays\": 1,\n    \"maxTotalDays\": 14,\n    \"holdDuration\": {\n      \"minutes\": 30\n    },\n    \"temporalWindows\": {\n      \"discoveryWindow\": {\n        \"open\": \"2026-01-01T07:00:00-08:00\",\n        \"close\": \"2026-12-31T23:59:59-08:00\"\n      }\n    }\n  },\n  \"temporalContext\": {\n    \"totalDays\": 0,\n    \"restrictedBookingTriggered\": false,\n    \"discoveryWindow\": {\n      \"open\": \"2026-01-01T07:00:00-08:00\",\n      \"close\": \"2026-12-31T23:59:59-08:00\"\n    },\n    \"checkInAnchor\": \"2026-02-09T14:00:00-08:00\",\n    \"checkOutAnchor\": \"2026-02-12T11:00:00-08:00\",\n    \"noShowAnchor\": \"2026-02-09T23:59:59-08:00\",\n    \"reservationTime\": \"2026-01-01T07:01:00-08:00\",\n    \"completionTime\": null,\n    \"arrivalDate\": \"2026-02-09\",\n    \"departureDate\": \"2026-02-12\"\n  },\n  \"partyPolicySnapshot\": {\n    \"partyCategories\": [\n      {\n        \"id\": \"adult\",\n        \"label\": \"Adult (18+)\",\n        \"minCount\": 1,\n        \"maxCount\": 4\n      },\n      {\n        \"id\": \"child\",\n        \"label\": \"Child &lt;18\",\n        \"minCount\": 0,\n        \"maxCount\": 3\n      },\n      {\n        \"id\": \"tent\",\n        \"label\": \"Tent\",\n        \"minCount\": 1,\n        \"maxCount\": 2\n      }\n    ],\n    \"partyCompositionRules\": [\n      {\n        \"id\": \"maxTotalPartySize\",\n        \"label\": \"Maximum Total Party Size\",\n        \"failMsg\": \"Total party size cannot exceed 4 people.\",\n        \"if\": [],\n        \"then\": {\n          \"lhs\": [\n            {\n              \"type\": \"ref\",\n              \"value\": \"partyCategory.adult\"\n            },\n            {\n              \"op\": \"add\"\n            },\n            {\n              \"type\": \"ref\",\n              \"value\": \"partyCategory.child\"\n            }\n          ],\n          \"op\": \"lte\",\n          \"rhs\": [\n            {\n              \"type\": \"constant\",\n              \"value\": 4\n            }\n          ]\n        }\n      }\n    ]\n  },\n  \"partyContext\": {\n    \"isValid\": false,\n    \"bookingDateValidations\": [\n      {\n        \"date\": \"2026-02-09\",\n        \"isValid\": false\n      },\n      {\n        \"date\": \"2026-02-11\",\n        \"isValid\": false\n      },\n      {\n        \"date\": \"2026-02-12\",\n        \"isValid\": false\n      }\n    ]\n  },\n  \"feePolicySnapshot\": {\n    \"feeSchedule\": [\n      {\n        \"id\": \"transactionFee\",\n        \"label\": \"Transaction Fee\",\n        \"type\": \"flat\",\n        \"amount\": 6.5\n      },\n      {\n        \"id\": \"tax\",\n        \"label\": \"Tax\",\n        \"type\": \"percentage\",\n        \"amount\": 0.05\n      }\n    ],\n    \"lineItems\": [\n      {\n        \"id\": \"transactionFeeLine\",\n        \"label\": \"Transaction Fee\",\n        \"type\": \"flat\",\n        \"if\": [],\n        \"quantity\": {\n          \"type\": \"constant\",\n          \"value\": 1\n        },\n        \"rate\": {\n          \"type\": \"field\",\n          \"value\": \"feeSchedule.transactionFee\"\n        },\n        \"taxApplied\": [\n          {\n            \"type\": \"field\",\n            \"value\": \"feeSchedule.tax\"\n          }\n        ],\n        \"discountsApplied\": [],\n        \"isReturnable\": false\n      }\n    ]\n  },\n  \"feeValues\": {\n    \"bookingDateTotals\": [\n      {\n        \"date\": \"2026-02-09\",\n        \"totalDiscounts\": [],\n        \"totalTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 0\n          }\n        ],\n        \"total\": 0\n      },\n      {\n        \"date\": \"2026-02-10\",\n        \"totalDiscounts\": [],\n        \"totalTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 0\n          }\n        ],\n        \"total\": 0\n      },\n      {\n        \"date\": \"2026-02-11\",\n        \"totalDiscounts\": [],\n        \"totalTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 0\n          }\n        ],\n        \"total\": 0\n      }\n    ],\n    \"resolvedLineItems\": [\n      {\n        \"id\": \"transactionFeeLine\",\n        \"label\": \"Transaction Fee\",\n        \"type\": \"flat\",\n        \"isReturnable\": false,\n        \"units\": [\n          {\n            \"rate\": 6.50,\n            \"discountsApplied\": [],\n            \"taxApplied\": [\n              {\n                \"id\": \"tax\",\n                \"rate\": 0.05,\n                \"amount\": 0.33\n              }\n            ],\n            \"unitSubTotal\": 6.50,\n            \"unitTotal\": 6.83\n          }\n        ],\n        \"lineTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 0.33\n          }\n        ],\n        \"lineDiscounts\": [],\n        \"lineSubTotal\": 6.50,\n        \"lineTotal\": 6.83\n      }\n    ],\n    \"bookingDiscounts\": [],\n    \"bookingTaxes\": [\n      {\n        \"id\": \"tax\",\n        \"rate\": 0.05,\n        \"amount\": 0.33\n      }\n    ],\n    \"bookingSubTotal\": 6.50,\n    \"bookingTotal\": 6.83\n  },\n  \"changePolicySnapshot\": {\n    \"rules\": [\n      {\n        \"id\": \"campingFeeFullRefund\",\n        \"label\": \"Full Camping Fee Refund\",\n        \"description\": \"Full refund of camping fees if cancellation occurs more than 2 weeks before arrival date.\",\n        \"if\": [],\n        \"type\": \"percentage\",\n        \"amount\": 1.0,\n        \"temporalWindow\": {\n          \"open\": \"2026-01-01T07:00:00-08:00\",\n          \"close\": \"2026-01-26T23:59:59-08:00\"\n        }\n      },\n      {\n        \"id\": \"campingFee50PercentRefund\",\n        \"label\": \"Half Camping Fee Refund\",\n        \"description\": \"Half refund of camping fees if cancellation occurs less than 2 weeks but more than 1 week before arrival date.\",\n        \"type\": \"percentage\",\n        \"if\": [],\n        \"amount\": 0.5,\n        \"temporalWindow\": {\n          \"open\": \"2026-01-27T07:00:00-08:00\",\n          \"close\": \"2026-02-02T23:59:59-08:00\"\n        }\n      }\n    ]\n  },\n  \"createdAt\": \"2026-01-01T07:01:00-08:00\",\n  \"lastUpdated\": \"2026-01-01T07:01:00-08:00\",\n  \"version\": 1\n}\n</code></pre>"},{"location":"datatypes/bookings/#after-finalization","title":"After Finalization","text":"<pre><code>{\n  \"pk\": \"booking::mockPark1::backcountryCamp::1::1\",\n  \"sk\": \"2026-02-09::550e8400-e29b-41d4-a716-446655440000\",\n  \"gsi1pk\": \"user::b7e6c2f2-3a1d-4e8a-9e0d-8c2a1b7e6c2f\",\n  \"gsi1sk\": \"2026-02-09\",\n  \"schema\": \"booking\",\n  \"globalId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"collectionId\": \"mockPark1\",\n  \"activityType\": \"backcountryCamp\",\n  \"activitySubType\": null,\n  \"activityId\": \"1\",\n  \"productId\": \"1\",\n  \"bookingId\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"userSub\": \"b7e6c2f2-3a1d-4e8a-9e0d-8c2a1b7e6c2f\",\n  \"status\": \"complete\",\n  \"timezone\": \"America/Vancouver\",\n  \"asset\": {\n    \"primaryKey\": {\n      \"pk\": \"asset::mockPark1::campground::1\",\n      \"sk\": \"campsite::1\"\n    },\n    \"allocationType\": \"fixed\",\n    \"quantity\": 1\n  },\n  \"itineraryRulesSnapshot\": {\n    \"entryExit\": {\n      \"required\": true,\n      \"allowedEntryPoints\": [\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::1\"\n        },\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::2\"\n        }\n      ],\n      \"allowedExitPoints\": [\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::1\"\n        },\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::2\"\n        }\n      ]\n    },\n    \"stayPoints\": {\n      \"required\": true,\n      \"allowedStayPoints\": [\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"campground::1\"\n        },\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"campground::2\"\n        }\n      ]\n    }\n  },\n  \"itinerary\": {\n    \"entryPoint\": {\n      \"primaryKey\": {\n        \"pk\": \"facility::mockPark1\",\n        \"sk\": \"accessPoint::1\"\n      },\n      \"date\": \"2026-02-09\",\n      \"displayName\": \"Mock Park South Trailhead\"\n    },\n    \"exitPoint\": {\n      \"primaryKey\": {\n        \"pk\": \"facility::mockPark1\",\n        \"sk\": \"accessPoint::2\"\n      },\n      \"date\": \"2026-02-12\",\n      \"displayName\": \"Mock Park North Trailhead\"\n    },\n    \"stayPoints\": [\n      {\n        \"primaryKey\": {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"campground::1\"\n        },\n        \"date\": \"2026-02-09\",\n        \"displayName\": \"Mock Park Campground A\"\n      },\n      {\n        \"primaryKey\": {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"campground::1\"\n        },\n        \"date\": \"2026-02-10\",\n        \"displayName\": \"Mock Park Campground A\"\n      },\n      {\n        \"primaryKey\": {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"campground::2\"\n        },\n        \"date\": \"2026-02-11\",\n        \"displayName\": \"Mock Park Campground B\"\n      }\n    ]\n  },\n  \"reservationPolicySnapshot\": {\n    \"isDiscoverable\": true,\n    \"isReservable\": true,\n    \"minTotalDays\": 1,\n    \"maxTotalDays\": 14,\n    \"holdDuration\": {\n      \"minutes\": 30\n    },\n    \"temporalWindows\": {\n      \"discoveryWindow\": {\n        \"open\": \"2026-01-01T07:00:00-08:00\",\n        \"close\": \"2026-12-31T23:59:59-08:00\"\n      }\n    }\n  },\n  \"reservationValues\": {\n    \"totalDays\": 3,\n    \"restrictedBookingTriggered\": false,\n    \"temporalAnchors\": {\n      \"reservationTime\": \"2026-01-01T07:00:00-08:00\",\n      \"arrivalDate\": \"2026-02-09\",\n      \"departureDate\": \"2026-02-12\",\n      \"checkInAnchor\": \"2026-02-09T14:00:00-08:00\",\n      \"noShowAnchor\": \"2026-02-09T23:59:59-08:00\"\n    }\n  },\n  \"partyPolicySnapshot\": {\n    \"partyCategories\": [\n      {\n        \"id\": \"adult\",\n        \"label\": \"Adult (18+)\",\n        \"minCount\": 1,\n        \"maxCount\": 4\n      },\n      {\n        \"id\": \"child\",\n        \"label\": \"Child &lt;18\",\n        \"minCount\": 0,\n        \"maxCount\": 3\n      },\n      {\n        \"id\": \"tent\",\n        \"label\": \"Tent\",\n        \"minCount\": 1,\n        \"maxCount\": 2\n      }\n    ],\n    \"partyCompositionRules\": [\n      {\n        \"id\": \"maxTotalPartySize\",\n        \"label\": \"Maximum Total Party Size\",\n        \"failMsg\": \"Total party size cannot exceed 4 people.\",\n        \"if\": [],\n        \"then\": {\n          \"lhs\": [\n            {\n              \"type\": \"partyCategory\",\n              \"value\": \"adult\"\n            },\n            {\n              \"op\": \"add\"\n            },\n            {\n              \"type\": \"partyCategory\",\n              \"value\": \"child\"\n            }\n          ],\n          \"op\": \"lte\",\n          \"rhs\": [\n            {\n              \"type\": \"constant\",\n              \"value\": 4\n            }\n          ]\n        }\n      }\n    ]\n  },\n  \"partyContext\": {\n    \"isValid\": true,\n    \"bookingDateValidations\": [\n      {\n        \"date\": \"2026-02-09\",\n        \"isValid\": true\n      },\n      {\n        \"date\": \"2026-02-11\",\n        \"isValid\": true\n      },\n      {\n        \"date\": \"2026-02-12\",\n        \"isValid\": true\n      }\n    ]\n  },\n  \"feePolicySnapshot\": {\n    \"feeSchedule\": [\n      {\n        \"id\": \"transactionFee\",\n        \"label\": \"Transaction Fee\",\n        \"type\": \"flat\",\n        \"amount\": 6.5\n      },\n      {\n        \"id\": \"tax\",\n        \"label\": \"Tax\",\n        \"type\": \"percentage\",\n        \"amount\": 0.05\n      }\n    ],\n    \"lineItems\": [\n      {\n        \"id\": \"transactionFeeLine\",\n        \"label\": \"Transaction Fee\",\n        \"type\": \"flat\",\n        \"if\": [],\n        \"quantity\": {\n          \"type\": \"constant\",\n          \"value\": 1\n        },\n        \"rate\": {\n          \"type\": \"field\",\n          \"value\": \"feeSchedule.transactionFee\"\n        },\n        \"taxApplied\": [\n          {\n            \"type\": \"field\",\n            \"value\": \"feeSchedule.tax\"\n          }\n        ],\n        \"discountsApplied\": [],\n        \"isReturnable\": false\n      }\n    ]\n  },\n  \"feeValues\": {\n    \"bookingDateTotals\": [\n      {\n        \"date\": \"2026-02-09\",\n        \"totalDiscounts\": [],\n        \"totalTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 2.00\n          }\n        ],\n        \"subTotal\": 40,\n        \"total\": 42\n      },\n      {\n        \"date\": \"2026-02-10\",\n        \"totalDiscounts\": [],\n        \"totalTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 2.00\n          }\n        ],\n        \"subTotal\": 40,\n        \"total\": 42\n      },\n      {\n        \"date\": \"2026-02-11\",\n        \"totalDiscounts\": [],\n        \"totalTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 2.00\n          }\n        ],\n        \"subTotal\": 40,\n        \"total\": 42\n      }\n    ],\n    \"resolvedLineItems\": [\n      {\n        \"id\": \"transactionFeeLine\",\n        \"label\": \"Transaction Fee\",\n        \"type\": \"flat\",\n        \"isReturnable\": false,\n        \"units\": [\n          {\n            \"rate\": 6.50,\n            \"discountsApplied\": [],\n            \"taxApplied\": [\n              {\n                \"id\": \"tax\",\n                \"rate\": 0.05,\n                \"amount\": 0.33\n              }\n            ],\n            \"unitSubTotal\": 6.50,\n            \"unitTotal\": 6.83\n          }\n        ],\n        \"lineTaxes\": [\n          {\n            \"id\": \"tax\",\n            \"rate\": 0.05,\n            \"amount\": 0.33\n          }\n        ],\n        \"lineDiscounts\": [],\n        \"lineSubTotal\": 6.50,\n        \"lineTotal\": 6.83\n      }\n    ],\n    \"bookingDiscounts\": [],\n    \"bookingTaxes\": [\n      {\n        \"id\": \"tax\",\n        \"rate\": 0.05,\n        \"amount\": 6.33\n      }\n    ],\n    \"bookingSubTotal\": 126.50,\n    \"bookingTotal\": 132.83\n  },\n  \"changePolicySnapshot\": {\n    \"rules\": [\n      {\n        \"id\": \"campingFeeFullRefund\",\n        \"label\": \"Full Camping Fee Refund\",\n        \"description\": \"Full refund of camping fees if cancellation occurs more than 2 weeks before arrival date.\",\n        \"if\": [],\n        \"type\": \"percentage\",\n        \"amount\": 1.0,\n        \"temporalWindow\": {\n          \"open\": \"2026-01-01T07:00:00-08:00\",\n          \"close\": \"2026-01-26T23:59:59-08:00\"\n        }\n      },\n      {\n        \"id\": \"campingFee50PercentRefund\",\n        \"label\": \"Half Camping Fee Refund\",\n        \"description\": \"Half refund of camping fees if cancellation occurs less than 2 weeks but more than 1 week before arrival date.\",\n        \"type\": \"percentage\",\n        \"if\": [],\n        \"amount\": 0.5,\n        \"temporalWindow\": {\n          \"open\": \"2026-01-27T07:00:00-08:00\",\n          \"close\": \"2026-02-02T23:59:59-08:00\"\n        }\n      }\n    ]\n  },\n  \"createdAt\": \"2026-01-01T07:01:00-08:00\",\n  \"lastUpdated\": \"2026-01-01T07:03:00-08:00\",\n  \"version\": 2\n}\n</code></pre>"},{"location":"datatypes/collections/","title":"Collections and Collection IDs","text":"<p>Historically, the reservation system used parks (protected areas) as the highest level of data categorization. Parks are uniquely identified by their ORCS number \u2014 a legally defined identifier managed by an external authority.</p> <p>This approach has proven too restrictive for a modern reservation system: - ORCS values cannot be created, modified, or merged by the system. - ORCS boundaries do not always align with real\u2011world experiences. - Some offerings span multiple parks or only portions of parks</p>"},{"location":"datatypes/collections/#example-desolation-sound","title":"Example - Desolation Sound","text":"<p>Desolation sound contains in part a single backcountry registration offering that spans multiple protected areas: * Desolation Sound Park (ORCS 252) * Malaspina Park (ORCS 6268) * Cope Islands Park (ORCS ???) * Roscoe Bay Park (ORCS 373)</p> <p>Under an ORCS-centric model, this experience cannot be represented cleanly.</p>"},{"location":"datatypes/collections/#collections","title":"Collections","text":"<p>To regain control of the data hierarchy, this data model introduces collections.</p> <p>A collection is the highest-level grouping of interrelated experiences in this data model. They are defined by operational reality, not legal boundaries.</p> <p>A collection may include: * one park * multiple parks * partial areas of parks * areas that are not parks at all</p> <p>This gives the system full flexibility to represent real\u2011world experiences without being constrained by external legal definitions.</p> <p>It is still possible to group experiences analogously to preexisting understandings where the protected area is the backbone of the grouping, like this example of Strathcona Park's BC Parks Collection:</p> <p></p> <p>With collections, we can also represent the aforementioned Desolation Sound scenario as shown in the following image.</p> <p></p>"},{"location":"datatypes/collections/#collection-ids","title":"Collection IDs","text":"<p>A collectionId uniquely identifies a collection.</p> <p>It does not need to follow any external standard - it only needs to be stable and unique, and be free of URL-reserved characters as they often appear in API paths.</p> <p>For collections that relate to BC Parks and the experiences offered by BC Parks, the convention is</p> <pre><code>bcparks_&lt;ORCS&gt;\n</code></pre>"},{"location":"datatypes/collections/#examples","title":"Examples:Collections are *not* a datatype (yet).","text":"<ul> <li>Strathcona Park (ORCS 1) =&gt; <code>bcparks_1</code></li> <li>A multi-park collection could be =&gt; <code>bcparks_252</code> or <code>bcparks_252_6268_373</code></li> </ul> <p>Collection IDs are used extensively in reference data to group related items across multiple schemas, ensuring that all data associated with a shared experience domain can be queried and reasoned about consistently.</p> <p>It is important to note:</p> <p>They do not represent a schema, entity, or object in the data model.</p> <p>They are purely labels used to associate related reference\u2011data items.</p> <p>(In the future, they may need to be converted to a datatype to include collection metadata, like a collection <code>displayName</code>).</p>"},{"location":"datatypes/facilities/","title":"Facilities","text":"<p>A facility is a specific, physical feature represented by a geographic point, polyline, or polygon. Facilities describe real\u2011world infrastructure or natural features that visitors interact with directly. They typically include man-made structures such as: parking lots, campgrounds, trailheads, buildings, and viewpoints, but they may also represent natural features such as lakes, beaches or mountains when those features are meaningful to the user experience.</p> <p>A single facility may support zero, one, or many activities, and users may require permission to visit, stay at, or otherwise use certain facilities.</p> <p>Facilities provide parental groupings for assets, which are the smallest spatial elements in the system.</p> <p>Although facilities may resemble legacy BC Parks concepts, they are a distinct datatype within this data model and are not derived from any preexisting structure.</p>"},{"location":"datatypes/facilities/#relationship-to-geozones","title":"Relationship to Geozones","text":"<p>Facilities and geozones are both spatial concepts, but they serve different purposes: - Facilities represent physical objects or specific locations. - Geozones represent conceptual regions that group multiple facilities, activities, or features.</p> <p>Even when a facility uses a polygon to describe its footprint, it remains a physical feature, not a regional grouping. This distinction keeps the spatial model clear, scalable, and easy to reason about.</p> <p>Like geozones, facilities can be: - system\u2011defined (BC Parks infrastructure) - user\u2011defined (personal points or areas of interest)</p> <p>Because facilities may belong to different audiences, they are grouped using <code>collectionIds</code>. - A facility in Strathcona Park (ORCS 1) \u2192 facility::bcparks_1</p>"},{"location":"datatypes/facilities/#properties","title":"Properties","text":"<p>Note: The facility configuration file is the authoritative source for the current schema.</p> Property Type Description <code>pk</code> String Partition key for the item. Always begins with <code>facility::&lt;collectionId&gt;</code>. Groups all facilities within a collection. <code>sk</code> String Sort key uniquely identifying the item within the partition. Typically a combination of <code>facilityType</code> and <code>identifier</code> <code>schema</code> String Item datatype/schema. Will always be 'facility' for facilities <code>globalId</code> String UUID used for GSIs and cross\u2011collection lookups. <code>collectionId</code> String Identifier linking the facility to its operational collection (e.g., <code>bcparks_1</code>). <code>facility</code> Number Identifier uniquely distinguishing this particular facility from other facilities of the same type within the same collection <code>identifier</code> Number See <code>facilityId</code> <code>facilityType</code> String The type of facility the item represents. Some examples include \"campground\", \"accessPoint\", and \"naturalFeature\" <code>facilitySubType</code> String If needed, a further categorization of the <code>facilityType</code>. Some examples of a \"naturalFeature\" might include a \"lake\", \"summit\" or \"waterfall\" <code>displayName</code> String Human\u2011readable name of the item. <code>description</code> String Optional descriptive text explaining the purpose or operational meaning of the item. <code>envelope</code> OSGeo Bounding box containing 2D spatial geometry, if it exists. <code>boundary</code> OSGeo Spatial footprint geometry, if it exists and small enough to be stored in DynamoDB. <code>boundaryUrl</code> String Spatial footprint geometry, if it exists. Stored in S3 with a reference URL. <code>location</code> OSGeo Geospatial point serving as the location of the facility, used for search relevance, sorting, clustering, and map pin placement <code>path</code> OSGeo Spatial polyline geometry, if it exists and small enough to be stored in DynamoDB. Usually will refer to a trail or road. <code>pathUrl</code> String Spatial polyline geometry, if it exists. Stored in S3 with a reference URL. <code>minMapZoom</code> Number The smallest zoom level (furthest zoomed out) at which the object will render on a map if it is not in focus <code>maxMapZoom</code> Number The largest zoom level (furthest zoomed in) at which the object will render on a map if it is not in focus <code>imageUrls</code> [String] Array of urls of images of this data item <code>timezone</code> String The IANA string timezone of the spatial data item <code>isVisible</code> Boolean Whether or not this item will be returned if it generates a search hit <code>creationDate</code> DateTime Timestamp of when the item was first created <code>lastUpdated</code> DateTime Timestamp of when the item was last updated <code>version</code> Number Data revision number <code>searchTerms</code> String Comma-separated list of terms OpenSearch can use to link text searches to this data item <code>adminNotes</code> String Administrative notes to describe the data, will never be surfaced to the public"},{"location":"datatypes/facilities/#examples","title":"Examples","text":""},{"location":"datatypes/facilities/#bedwell-lake-campground","title":"Bedwell Lake Campground","text":"<pre><code>{\n  \"pk\": \"facility::bcparks_1\",\n  \"sk\": \"campground::1\",\n  \"schema\": \"facility\",\n  \"globalId\": \"23ertrg4-t54e-tyhr-ghnj-rer4323e543t\",\n  \"collectionId\": \"bcparks_1\",\n  \"facilityType\": \"campground\",\n  \"facilitySubType\": \"\",\n  \"facilityId\": 1,\n  \"identifier\": 1,\n  \"displayName\": \"Bedwell Lake Campground\",\n  \"description\": \"Main Bedwell Lake campground on the edge of pristine Bedwell Lake. There are ### tentpads at this campground\",\n  \"envelope\": {\n    \"type\": \"envelope\",\n    \"coordinates\": [\n      [-125.61, 49.51],\n      [-125.60, 49.50]\n    ]\n  },\n  \"boundaryUrl\": \"s3://...\",\n  \"location\": {\n    \"type\": \"point\",\n    \"coordinates\": [\n      -125.592,\n      49.490\n    ]\n  },\n  \"path\": {},\n  \"minMapZoom\": 9,\n  \"maxMapZoom\": 19,\n  \"imageUrls\": [\n    \"https://...\",\n    \"https://...\"\n  ],\n  \"timezone\": \"America/Vancouver\",\n  \"isVisible\": true,\n  \"creationDate\": \"2026-01-06T15:30:00.000Z\",\n  \"lastUpdated\": \"2026-01-06T15:30:00.000Z\",\n  \"version\": 1,\n  \"searchTerms\": \"bedwell lake, baby bedwell lake, strathcona park...\",\n  \"adminNotes\": \"\"\n}\n</code></pre>"},{"location":"datatypes/facilities/#juan-de-fuca-trail","title":"Juan de Fuca Trail","text":"<pre><code>{\n  \"pk\": \"facility::bcparks_9398\",\n  \"sk\": \"trailSegment::1\",\n  \"schema\": \"facility\",\n  \"globalId\": \"2342fg4-r4rr-asf4-ytrt-rt345ertae543t\",\n  \"collectionId\": \"bcparks_1\",\n  \"facilityType\": \"trailSegment\",\n  \"facilitySubType\": \"\",\n  \"facilityId\": 1,\n  \"identifier\": 1,\n  \"displayName\": \"Juan de Fuca Trail\",\n  \"description\": \"Coastal Trail on southwest Vancouver Island spanning from China Beach to Botanical Beach\",\n  \"envelope\": {\n    \"type\": \"envelope\",\n    \"coordinates\": [\n      [\n        -125.61,\n        49.51\n      ],\n      [\n        -125.60,\n        49.50\n      ]\n    ]\n  },\n  \"boundaryUrl\": \"s3://...\",\n  \"location\": {\n    \"type\": \"point\",\n    \"coordinates\": [\n      -124.093,\n      48.438\n    ]\n  },\n  \"path\": {\n    \"type\": \"polyline\",\n    \"coordinates\": [\n      [\n        -124.093,\n        48.438\n      ],\n      [\n        -124.092,\n        48.437\n      ],\n      [\n        -124.091,\n        48.436\n      ]\n    ]\n  },\n  \"minMapZoom\": 5,\n  \"maxMapZoom\": 20,\n  \"imageUrls\": [\n    \"https://...\",\n    \"https://...\"\n  ],\n  \"timezone\": \"America/Vancouver\",\n  \"isVisible\": true,\n  \"creationDate\": \"2026-01-06T15:30:00.000Z\",\n  \"lastUpdated\": \"2026-01-06T15:30:00.000Z\",\n  \"version\": 1,\n  \"searchTerms\": \"juan de fuca, china beach, chin beach, bear beach, sombrio beach, botanical beach, payzant...\",\n  \"adminNotes\": \"\"\n}\n</code></pre>"},{"location":"datatypes/geozones/","title":"Geozones","text":"<p>A geozone is a system\u2011defined spatial region used to group interrelated facilities, activities, and other geolocated data. Its defining feature is a geospatial polygon or bounding box that describes the physical boundary of the geozone. Geozones represent operational or experiential areas of interest \u2014 not legal boundaries \u2014 and provide a flexible way to describe geospatial regions meaningfully without the context of preexisting datatypes, such as parks/protected areas/subareas.</p> <p>Protected areas can be extremely large and often contain vast regions with no visitor\u2011facing features. Geozones allow the system to focus on the specific areas that matter to users and administrators.</p> <p>Geozones vary in size, but each one is designed to: - group features that are meaningfully related - be viewable on a single map without losing spatial clarity - accurately convey proximity, distance, and relationships - support rich search, discovery, and navigation experiences</p>"},{"location":"datatypes/geozones/#public-use-cases","title":"Public Use Cases","text":"<p>Geozones can represent visitor\u2011facing experiences such as: - \u201cBedwell Lakes\u201d within Strathcona Park - \u201cCheakamus Lake Area\u201d within Garibaldi</p> <p>A geozone can serve as a landing zone for search queries (e.g., a user searching \u201cbedwell\u201d can be routed directly to the Bedwell Lakes geozone, even though it is only a subregion of Strathcona Park).</p>"},{"location":"datatypes/geozones/#administrative-use-cases","title":"Administrative Use Cases","text":"<p>Geozones can also group features that share: - operational responsibilities - maintenance bundles - management workflow</p> <p>This allows staff to work with meaningful operational regions (bundles) rather than legal park boundaries.</p>"},{"location":"datatypes/geozones/#custom-user-defined-geozones","title":"Custom User-Defined Geozones","text":"<p>Authenticated users may define their own geozones for personal use \u2014 for example, marking a favourite backcountry loop or a region they frequently monitor. These user\u2011defined geozones live in their own collections and do not affect public or administrative geozones.</p>"},{"location":"datatypes/geozones/#dynamodb-partitioning","title":"DynamoDB Partitioning","text":"<p>Geozones use a compound primary key:</p> <pre><code>pk: geozone::&lt;collectionId&gt;\nsk: &lt;geozoneId&gt;\n</code></pre> <p>Example \u2014 BC Parks geozone relating to Garibaldi Provincial Park (ORCS 7) <pre><code>pk: geozone::bcparks_7\nsk: 1\n</code></pre></p> <p>Querying this partition returns all geozones associated with the Garibaldi collection, enabling front\u2011end applications to build spatially meaningful home pages and navigation flows.</p> <p>Example \u2014 User\u2011Defined Geozone pk: geozone::user_12345 sk: 1</p> <p>High cardinality of <code>collectionId</code> ensures DynamoDB performance remains stable regardless of the number of geozones in the system.</p>"},{"location":"datatypes/geozones/#properties","title":"Properties","text":"<p>Note: The geozone configuration file is the authoritative source for the current schema.</p> Property Type Description <code>pk</code> String Partition key for the geozone. Always begins with <code>geozone::&lt;collectionId&gt;</code>. Groups all geozones within a collection. <code>sk</code> String Sort key uniquely identifying the geozone within the partition. Typically <code>geozoneId</code> <code>schema</code> String The datatype/schema. Will always be 'geozone' for geozones <code>globalId</code> String UUID used for GSIs and cross\u2011collection lookups. <code>collectionId</code> String Identifier linking the geozone to its operational collection (e.g., <code>bcparks_1</code>). <code>geozoneId</code> Number Identifier uniquely distinguishing this particular geozone from other geozones within the same collection <code>identifier</code> Number See <code>geozoneId</code> <code>displayName</code> String Human\u2011readable name of the geozone. <code>description</code> String Optional descriptive text explaining the purpose or operational meaning of the geozone. <code>envelope</code> OSGeo Bounding box containing authoritative spatial geometry. <code>boundary</code> OSGeo Authoritative spatial geometry, if it fits in DynamoDB. <code>boundaryUrl</code> String Authoritative spatial geometry. Stored in S3 with a reference URL. <code>location</code> OSGeo Geospatial point serving as a simplified point used for search relevance, sorting, clustering, and map pin placement <code>minMapZoom</code> Number The smallest zoom level (furthest zoomed out) at which the object will render on a map if it is not in focus <code>maxMapZoom</code> Number The largest zoom level (furthest zoomed in) at which the object will render on a map if it is not in focus <code>imageUrls</code> [String] Array of urls of images of this data item <code>timezone</code> String The IANA string timezone of the spatial data item <code>isVisible</code> Boolean Whether or not this item will be returned if it generates a search hit <code>creationDate</code> DateTime Timestamp of when the item was first created <code>lastUpdated</code> DateTime Timestamp of when the item was last updated <code>version</code> Number Data revision number <code>searchTerms</code> String Comma-separated list of terms OpenSearch can use to link text searches to this data item <code>adminNotes</code> String Administrative notes to describe the data, will never be surfaced to the public"},{"location":"datatypes/geozones/#examples","title":"Examples","text":""},{"location":"datatypes/geozones/#bedwell-trail-area","title":"Bedwell Trail Area","text":"<p>This geozone might be used to encompass the limits of the Bedwell Trail Area, showing the boundary of the backcountry area and the backcountry camping sites contained within.</p> <pre><code>{\n  \"pk\": \"geozone::bcparks_1\",\n  \"sk\": \"2\",\n  \"schema\": \"geozone\",\n  \"globalId\": \"345fg5e-4b7a-4c9f-9f22-1a4e8c9d77aa\",\n  \"collectionId\": \"bcparks_1\",\n  \"geozoneId\": 2,\n  \"identifier\": 2,\n  \"displayName\": \"Bedwell Trail Area\",\n  \"description\": \"The Bedwell Lake Trail area in Strathcona Provincial Park is a steep but well\u2011built route leading to spectacular subalpine lakes surrounded by rugged mountain peaks, offering some of the park\u2019s best day\u2011hiking and backcountry camping.\",\n  \"envelope\": {\n    \"type\": \"envelope\",\n    \"coordinates\": [\n      [-125.610, 49.522],\n      [-125.522, 49.482]\n    ]\n  },\n  \"boundary\": {\n    \"type\": \"polygon\",\n    \"coordinates\": [\n      [-125.000, 49.000],\n      [-125.000, 49.000]\n    ]\n  },\n  \"boundaryUrl\": \"\",\n  \"location\": {\n    \"type\": \"point\",\n    \"coordinates\": [-125.589, 49.498]\n  },\n\n  \"minMapZoom\": 8,\n  \"maxMapZoom\": 18,\n  \"imageUrls\": [\n    \"https://...\",\n    \"https://...\"\n  ],\n  \"timezone\": \"America/Vancouver\",\n  \"isVisible\": true,\n  \"creationDate\": \"2026-01-05T22:30:00.000Z\",\n  \"lastUpdated\": \"2026-01-05T22:30:00.000Z\",\n  \"version\": 1,\n  \"searchTerms\": \"bedwell lake, baby bedwell lake, cream lake...\",\n  \"adminNotes\": \"...\"\n}\n</code></pre>"},{"location":"datatypes/geozones/#strathcona-provincial-park","title":"Strathcona Provincial Park","text":"<p>This example geozone shows how a park may be represented as a special kind of geozone. An additional field <code>orcs</code> pertaining to the ORCS ID, or some other field signifying this special geozone case, could be added if absolutely necessary.</p> <pre><code>{\n  \"pk\": \"geozone::bcparks_1\",\n  \"sk\": \"1\",\n  \"schema\": \"geozone\",\n  \"globalId\": \"8f3c2d1e-4b7a-4c9f-9f22-1a4e8c9d77aa\",\n  \"collectionId\": \"bcparks_1\",\n  \"geozoneId\": 1,\n  \"identifier\": 1,\n  \"displayName\": \"Strathcona Provincial Park\",\n  \"description\": \" BC's oldest park on Vancouver Island, offering camping, hiking, and other wilderness experiences.\",\n  \"envelope\": {\n    \"type\": \"envelope\",\n    \"coordinates\": [\n      [-125.000, 49.000],\n      [-125.000, 49.000]\n    ]\n  },\n  \"boundary\": {},\n  \"boundaryUrl\": \"s3://...\",\n  \"location\": {\n    \"type\": \"point\",\n    \"coordinates\": [-125.000, 49.000]\n  },\n  \"minMapZoom\": 6,\n  \"maxMapZoom\": 16,\n  \"imageUrls\": [\n    \"https://...\",\n    \"https://...\"\n  ],\n  \"timezone\": \"America/Vancouver\",\n  \"isVisible\": true,\n  \"creationDate\": \"2026-01-05T22:30:00.000Z\",\n  \"lastUpdated\": \"2026-01-05T22:30:00.000Z\",\n  \"version\": 1,\n  \"searchTerms\": \"buttle lake, strathcona, forbidden plateau, bedwell lake, elk river...\",\n  \"adminNotes\": \"...\"\n}\n</code></pre>"},{"location":"datatypes/geozones/#protected-areas","title":"Protected Areas","text":"<p>Also known as 'parks', these datatypes were the backbone of older systems and are uniquely defined by the legally designated ORCS number assigned to each protected area. The concept of a 'park' or 'protected area' is shared by several areas of BC Parks so the definition used in this model is analogous to those pre-understood concepts.</p> <p>However, because the preexisting concept of a protected area is rooted in its legal definition, it is unable to change to accommodate the wide range of use cases this data model demands. This makes the protected area datatype a poor candidate for the backbone of this model.</p> <p>Collections remain the backbone of the data model, and geozones remain the datatype at the very top of the data hierarchy. Protected areas can be represented as a subset of geozones and linked to collections as necessary to maintain continuity with historical systems or regulator requirements. See the Strathcona Provincial Park example of how this might be achieved.</p>"},{"location":"datatypes/inventory/","title":"Inventory","text":"<p>Inventory represents the most granular, indivisible unit of an offering. It is the smallest unit of availability that can be claimed by exactly one user at a time.</p> <p>It always corresponds to: - A specific date (e.g., May 1, 2026) - A specific Asset (e.g., Campsite A)</p> <p>This makes Inventory the foundation of the reservation system's concurrency model.</p>"},{"location":"datatypes/inventory/#types-of-inventory","title":"Types of Inventory","text":"<p>Inventory comes in two forms, fixed and flex, inherited from the Asset they represent. This distinction determines how the basic rules of how Inventory is allocated and reserved.</p>"},{"location":"datatypes/inventory/#fixed-inventory","title":"Fixed Inventory","text":"<p>Fixed Inventory corresponds to Assets that have a fixed, inflexible limit of discrete units. Fixed Inventory typically refers to a specific physical Asset (e.g. Campsite A). If a user's Booking covers multiple days, they will be allocated multiple units of Inventory, but in the case of a fixed Asset, each Inventory unit must correspond to the same Asset (e.g. Campsite A on May 1, 2026, Campsite A on May 2, 2026, etc.). Pools of fixed Inventory can represent many Assets per day, but must have at most one unit of Inventory per Asset per date.</p>"},{"location":"datatypes/inventory/#flex-inventory","title":"Flex Inventory","text":"<p>Flex Inventory corresponds to Assets that have a flexible limit of units that can be allocated. Flex Inventory typically refers to conceptual Assets (e.g., \"trail passes\"). There is no requirement that multiple units of Flex Inventory allocated to a single Booking correspond to the same Asset. For example, if a user's Booking covers multiple days, they may be allocated different units of Flex Inventory for each day (e.g., Trail Pass for May 1, 2026, Trail Pass for May 2, 2026, etc.). Pools of flex Inventory can represent at most one Asset per day, but can have many units of Inventory per Asset per date.</p> <p>A Booking may have multiple units of Inventory allocated to it, but all units of Inventory allocated to a single Booking must refer to the same Asset. This means that a Booking cannot be allocated both fixed and flex Inventory, since they correspond to different Assets.</p>"},{"location":"datatypes/inventory/#inventory-lifecycle","title":"Inventory Lifecycle","text":"<p>Inventory provides the clearest, most accurate representation of availability for a Product on a specific date. Any availability check, whether for a single date or an entire season, ultimately depends on the state of the underlying Inventory.</p> <p>Products and ProductDates, configured by system administrators, define the operational scaffolding from which Inventory is generated. Administrators determine how far into the future they want the system to support Bookings, configure the Product and ProductDates accordingly, and then run a generation script that seeds Inventory for that window.</p> <p>Ideally, this generation process occurs well before the public begins browsing or reserving, and is rarely, if ever, re-run. Without pre\u2011seeded Inventory, the system has nothing to allocate, and users may encounter gaps or degraded functionality.</p> <p>Determining how far into the future to seed Inventory is a balance between operational overhead and user experience. Seeding too little Inventory means more frequent generation, which can be operationally burdensome and may introduce availability gaps if not managed carefully. Seeding too much Inventory may lead to wasted resources if Products or ProductDates change their operational details, necessitating Inventory adjustments.</p> <p>Inventory acts as the allocation state machine for the system. Inventory can occupy the following states:</p> <ul> <li>Available - This Inventory unit is available to be reserved by users. It has not yet been claimed by any user, and can be allocated to a Booking if the user meets all necessary requirements.</li> <li>Held - This Inventory unit has been claimed by a user and allocated to their Booking. It is no longer available for other users to reserve, but the user has not yet completed the booking process (e.g., payment).</li> <li>Reserved - This Inventory unit has been claimed by a user, allocated to their Booking, and the user has completed the booking process (e.g., payment). It is no longer available for other users to reserve.</li> <li>Releasing - This Inventory unit was previously reserved, but is now in the process of being returned or exchanged by the user. For validation purposes, the Inventory cannot be considered part of the user's active reservation anymore, but also cannot yet be made available to other users until the release process is complete, in case the return fails.</li> </ul> <p>The phases of this state machine are:</p> <ul> <li>Seeding</li> <li>Discovery and Alignment</li> <li>Commitment</li> <li>Retirement</li> </ul>"},{"location":"datatypes/inventory/#seeding","title":"Seeding","text":"<p>Inventory is generated through a seeding process that creates Inventory units based on the configuration of Products and ProductDates. This process is typically run by administrators and should occur well before users begin browsing or reserving, and involves iterating through the configured Products and ProductDates, determining the corresponding Assets, and creating Inventory units for each combination of ProductDate and Asset according to the allocation type (fixed or flex). Each Inventory unit is initialized with the appropriate properties, such as allocation status (initially Available), references to the corresponding ProductDate and Asset, and a unique identifier. After seeding, the Inventory is ready to be allocated to users as they make reservations - but its discoverablity and allocability will depend on the specific configuration of the Product and ProductDate it corresponds to.</p>"},{"location":"datatypes/inventory/#discovery-and-alignment","title":"Discovery and Alignment","text":"<p>Users discover Inventory through the offerings presented to them as they browse, however, users only interact directly with Inventory when they request to claim it. Before requesting, ProductDates ensure the user is informed regarding what Inventory they are requesting and the estimated availability of that Inventory. When a user makes a request to claim Inventory, the system checks for Available Inventory that matches the user's desired Product and date(s), and if the user meets all necessary requirements, transitions the Inventory to Held, instantiates a Booking and allocates the Inventory to that Booking.</p> <p>From the Held state, the user can complete the reservation process, which transitions the Inventory to Reserved. If the user fails to complete the reservation process within a certain timeframe, or if they abandon their reservation, the Inventory can be transitioned back to Available, making it discoverable and allocable to other users again.</p>"},{"location":"datatypes/inventory/#commitment","title":"Commitment","text":"<p>When a user completes the reservation process (e.g., payment), the system transitions the allocated Inventory from Held to Reserved, marking it as officially claimed by the user. It will remain in this state forever, or until the user initiates a return or exchange, at which point it will transition to Releasing.</p>"},{"location":"datatypes/inventory/#retirement","title":"Retirement","text":"<p>If the Inventory is unclaimed and the date associated with the Inventory passes, or the Asset it corresponds to is decommissioned, or if any of the underlying Product or ProductDate configurations change in a way that invalidates the Inventory, it is retired. Retiring Inventory typically involves scuttling it, removing it from the system, or marking it as inactive, ensuring it is no longer available for reservation.</p>"},{"location":"datatypes/inventory/#returning-inventory-to-the-availability-pool","title":"Returning Inventory to the Availability Pool","text":"<p>Every time Inventory transitions back to Available, it must be validated to ensure it can be returned to the availability pool. This involves checking that the Inventory's date has not yet passed, that the corresponding Asset is still active, and that the underlying Product and ProductDate configurations have not changed. If any of these checks fail, the Inventory cannot be returned to the availability pool, and must instead be retired.</p> <p>Inventory that has been 'spent', that is, reserved and then used (e.g., the user checked in to their campsite on the reserved date), is implicitly retired, as it cannot be returned to the availability pool.</p>"},{"location":"datatypes/inventory/#reseeding","title":"Reseeding","text":"<p>Sometimes the governing strucutre of a Product or ProductDate changes after Inventory has already been seeded. For example, the Asset that a ProductDate references may change, or the allocation type of that Asset may change, which would invalidate the existing Inventory. In these cases, the affected Available Inventory must be scuttled and re-seeded according to the new configuration. Fully allocated Inventory (Reserved) must remain untouched, so re-seeding processes must this in. This process is operationally intensive and can lead to availability gaps if not managed carefully.</p>"},{"location":"datatypes/inventory/#properties","title":"Properties","text":""},{"location":"datatypes/inventory/#inventory_1","title":"Inventory","text":"<p>As Inventory's primary purpose is concurrency control, it has relatively few properties. Policies governing how Inventory is allocated and reserved are defined at the Product and ProductDate level, but Inventory itself only has properties that are necessary for reference and for enforcing concurrency.</p> property type description derived from evaluated when <code>pk</code> String Partition key \"inventory::\\::\\::\\::\\::\\\" Identifying the Inventory pool for a specific Product on a specific date <code>sk</code> String Sort key \"asset::\\::\\::\\::\\::\\::\\\" Identifying the specific Asset within the Inventory pool <code>gsipk</code> String Global secondary index partition key Reserved Reserved <code>gsisk</code> String Global secondary index sort key Reserved Reserved <code>schema</code> String Data type/Schema \"inventory\" Identifying that this item is \"inventory\" <code>globalId</code> String Globally unique UUID Automatically generating on Inventory seed Searching for this specific item using the <code>globalId</code> GSI <code>inventoryId</code> String Unique identifier for the Inventory unit (for fixed inventory this will always be 1) Auto-generated on Inventory seed Distinguishing this Inventory unit from others in the same pool (fixed assets inherently do this already, but flex assets do not) <code>allocationType</code> String The allocation type of this Inventory unit, either \"fixed\" or \"flex\" Referenced Asset Determining how this Inventory unit can be allocated <code>assetRef</code> PrimaryKey Reference to the Asset that this Inventory unit corresponds to Referenced Asset Identifying which Asset this Inventory unit is associated with <code>assetVersion</code> String The version of the Asset at the time this Inventory unit was seeded Referenced Asset Ensuring consistency between the Inventory unit and the Asset it is associated with <code>date</code> Date The calendar date that this Inventory unit is available for reservation Referenced ProductDate Identifying which date this Inventory unit is associated with <code>productDateRef</code> PrimaryKey Reference to the ProductDate that this Inventory unit is available for reservation Referenced ProductDate Identifying which ProductDate this Inventory unit is associated with <code>productDateVersion</code> String The version of the ProductDate at the time this Inventory unit was seeded Referenced ProductDate Ensuring consistency between the Inventory unit and the ProductDate it is associated with <code>allocationStatus</code> String The allocation status of this Inventory unit, either \"available\", \"reserved\", \"held\", \"releasing\" Current Inventory allocation state Determining whether this unit is available to be reserved, or already claimed <code>createdAt</code> Timestamp The timestamp when this Inventory unit was created Automatically generating on Inventory seed Tracking when this Inventory unit was created"},{"location":"datatypes/inventory/#example","title":"Example","text":"<pre><code>{\n  \"pk\": \"inventory::mockPark1::backcountryCamp::1::1::2026-02-09\",\n  \"sk\": \"asset::mockPark1::campground::1::tentPad::6::1\",\n  \"schema\": \"inventory\",\n  \"globalId\": \"c8e7a2b7-6f3d-4e2a-9c8a-2f1b7d8e5a4c\",\n  \"inventoryId\": 1,\n  \"allocationType\": \"fixed\",\n  \"assetRef\": {\n    \"pk\": \"asset::mockPark1::campground::1\",\n    \"sk\": \"campsite::6\"\n  },\n  \"date\": \"2026-02-09\",\n  \"productDateRef\": {\n    \"pk\": \"productDate::mockPark1::backcountryCamp::1::1\",\n    \"sk\": \"2026-02-09\"\n  },\n  \"productDateVersion\": 1,\n  \"allocationStatus\": \"available\",\n  \"createdAt\": \"2025-12-01T12:00:00Z\"\n}\n</code></pre>"},{"location":"datatypes/product-dates/","title":"ProductDate","text":"<p>A ProductDate represents a specific offering of a Product on a particular date. Each ProductDate is associated with a single Product, and inherits properties from the parent Product while also allowing for overrides at the ProductDate level. This allows for flexible management of offerings that may have different availability, reservation policies, booking policies, fee policies, or change policies on different dates.</p>"},{"location":"datatypes/product-dates/#productdates-as-system-governance-modules","title":"ProductDates as System Governance Modules","text":"<p>ProductDates are where the system enforces time-dependent rules and policies that govern how users can interact with offerings on specific dates. For each date that a Product is offered, the corresponding ProductDate captures specifically how that offering will behave on that date. This includes:</p> <ul> <li>When the specific date of the offering is discoverable to users</li> <li>When the specific date of the offering can be reserved by users</li> <li>If the date is the user's arrival date, when they can check in</li> <li>If the date is the user's departure date, when they can check out</li> <li>If the date is the user's arrival date, when the cutoffs for making or changing/cancellations to reservations are</li> <li>If the date is the user's arrival date, when the cutoff before no-shows is</li> <li>When the specific date of the offering incurs a booking restriction and changes are permanently disallowed</li> <li>The estimated availability for booking on that date</li> <li>The specific assets allocated for that date</li> </ul>"},{"location":"datatypes/product-dates/#properties","title":"Properties","text":""},{"location":"datatypes/product-dates/#productdate_1","title":"ProductDate","text":"property type description derived from evaluated when <code>pk</code> String Partition key productDate::<code>collectionId</code>::<code>activityType</code>::<code>activityId</code>::<code>productId</code> Searching for all ProductDates related to a specific Product. <code>sk</code> String Sort key <code>date</code> Searching for a specific ProductDate related to a specific Product (disambiguated by date) <code>gsipk</code> String Global secondary index partition key Reserved Reserved <code>gsisk</code> String Global secondary index sort key Reserved Reserved <code>schema</code> String Data type/Schema \"productDate\" Identifying that this item is a \"productDate\" <code>globalId</code> String Globally unique UUID Automatically generating on ProductDate POST Searching for this specific item using the <code>globalId</code> GSI <code>collectionId</code> String The identifier of the collection this ProductDate belongs to Parent Product's <code>collectionId</code> Determining which collection this ProductDate belongs to <code>activityType</code> String The identifier of the activity type this ProductDate belongs to Parent Product's <code>activityType</code> Determining which activity type this ProductDate belongs to <code>activityId</code> String The identifier of the activity this ProductDate belongs to Parent Product's <code>activityId</code> Determining which activity this ProductDate belongs to <code>productId</code> Number The unique identifier of the parent Product Parent Product's <code>productId</code> Determining which specific Product within the <code>collectionId</code> that this ProductDate refers to <code>date</code> Date Calendar date uniquely identifying this ProductDate from other ProductDates with the same partition key Automatically generating  on ProductDate POST Distinguishing this ProductDate from other ProductDates with the same partition key <code>displayName?</code> String A human-readable name for this ProductDate. Administrators on PUT/POST Providing a  human-readable title of the offering captured by this ProductDate (likely administrator facing) <code>description?</code> String Descriptive text explaining the operational meaning of this ProductDate Administrators on PUT/POST Providing a human-readable description of the offering captured by this ProductDate (may be used to explain how policies on this date differ from the parent Product) <code>availabilitySignal</code> PrimaryKey A reference to an AvailabilitySignal object containing an eventually-consistent estimate of the availability for booking on this date. Determined inherently from parent Product Providing a reference to an item containing estimate of availability for display to users or for internal planning <code>allDatesBookedIntervalIds?</code> [String] An array of DateInterval IDs representing periods of time where a Booking must contain all DateInterval dates if one date touches the DateInterval Parent Product Determining if a booking of this ProductDate must contain all dates within any of the defined date intervals if one of the dates in the booking touches any of the dates in the date interval <code>assetList</code> [AssetRef] A list of assetRefs allocated for this ProductDate. Derived from parent Product's <code>assetList</code> or overridden by administrators on PUT/POST Determining which assetRefs are allocated through this offering on this specific date, potentially overriding the parent Product's <code>assetList</code>. <code>reservationPolicy</code> ProductDateReservationPolicyRef Reference to the reservation policy that governs reservations of this ProductDate. Inherited from parent Product or overridden by administrators on PUT/POST Determining which reservation policy applies to reservations of this ProductDate, potentially overriding the parent Product's <code>reservationPolicy</code>. <code>feePolicy</code> ProductDateFeePolicyRef Reference to the fee policy that governs fees applied to bookings of this ProductDate. Inherited from parent Product or overridden by administrators on PUT/POST Determining which fee policy applies to bookings of this ProductDate, potentially overriding the parent Product's <code>feePolicy</code>. <code>creationDate</code> String ISO 8601 timestamp of when this item was created Administrators on POST Determining when this item was created <code>lastUpdated</code> String ISO 8601 timestamp of when this item was last updated Administrators on PUT/POST Determining when this item was last updated <code>version</code> Number Version number for optimistic locking Automatically incremented on PUT/POST Ensuring that updates to this item do not overwrite more recent changes made by other processes"},{"location":"datatypes/product-dates/#availabilityestimate","title":"AvailabilityEstimate","text":"property type description derived from evaluated when <code>availabilitySignalVersion</code> Number The version number of the availability signal used to generate this estimate. Copied from the latest version of the AvailabilitySignal when updated Tracking which version of the availability signal was used to generate this estimate, which can be used to compare and determine when availability may have changed <code>type</code> String The type of availability estimate (e.g., \"exact\", \"tiered\") Derived from the <code>estimationMode</code> in the parent Product's <code>availabilityEstimationPattern</code> Determining how to interpret the availability estimate for this ProductDate <code>value</code> Number or String The value of the availability estimate, which could be a number (e.g., count of available items) or a string (e.g., \"high\", \"medium\", \"low\") depending on the <code>type</code> Calculated based on the <code>estimationMode</code> and the logic defined in the availability estimation process Providing an estimate of availability for this ProductDate that can be used for display to users or for internal planning <code>lastUpdated</code> DateTime The timestamp of when this availability estimate was last updated. Automatically set when the availability estimate is recalculated Tracking the freshness of the availability estimate for this ProductDate"},{"location":"datatypes/product-dates/#productdatereservationpolicyref","title":"ProductDateReservationPolicyRef","text":"<p>A ProductDateReservationPolicyRef defines a reference to a reservation policy that governs how reservations are made for this particular ProductDate. A ProductDateReservationPolicyRef will fully resolve rules that apply at the ProductDate level.</p> <p>The related ReservationPolicy is exclusively applied to this ProductDate when enforcing reservation rules. Therefore, the primary key of the ReservationPolicy can be inferred.</p> property type description derived from evaluated when <code>isDiscoverable</code> Boolean Indicates whether this ProductDate is discoverable by users. Administrators on PUT/POST Determining if this ProductDate should be visible to users during the booking process. <code>isReservable</code> Boolean Indicates whether this ProductDate can be reserved by users. Administrators on PUT/POST Determining if users are allowed to make reservations for this ProductDate. <code>minDailyInventory</code> Number The minimum daily inventory that must be claimed by a user to initialize a Booking Administrators on PUT/POST Enforcing minimum inventory requirements for reservations on this ProductDate. <code>maxDailyInventory</code> Number The maximum daily inventory that can be claimed by a user to initialize a Booking Administrators on PUT/POST Enforcing maximum inventory limits for reservations on this ProductDate. <code>temporalWindows</code> ProductDateReservationTemporalWindows The temporal windows that govern when reservations can be made for this ProductDate. Administrators on PUT/POST Enforcing time-based rules for when reservations can be made for this ProductDate. <code>temporalAnchors</code> ProductDateReservationTemporalAnchors The temporal anchors that define key time points for reservation rules on this ProductDate. Administrators on PUT/POST Determining the reference points for time-based reservation rules for this ProductDate."},{"location":"datatypes/product-dates/#productdatereservationtemporalwindows","title":"ProductDateReservationTemporalWindows","text":"property type description derived from evaluated when <code>discoveryWindow</code> ResolvedTemporalWindow The temporal window during which this ProductDate is discoverable by users. Administrators on PUT/POST Enforcing the time period when this ProductDate is visible to users. <code>reservationWindow</code> ResolvedTemporalWindow The temporal window during which reservations can be made for this ProductDate. Administrators on PUT/POST Enforcing the time period when reservations can be made for this ProductDate. <code>restrictedBookingWindow</code> ResolvedTemporalWindow The temporal window during which reservations for this ProductDate incur a booking restriction and changes are permanently disallowed. Administrators on PUT/POST Enforcing the time period when reservations for this ProductDate cannot be changed."},{"location":"datatypes/product-dates/#productdatereservationtemporalanchors","title":"ProductDateReservationTemporalAnchors","text":"<p>A resolved temporal anchor is functionally equivalent to a specific timestamp, but is derived from dynamic inputs such as the check-in time of a reservation. This allows for more flexible and context-aware booking rules that can adapt based on the specifics of each reservation.</p> property type description derived from evaluated when <code>checkInAnchor</code> TimeStamp The temporal anchor defining the check-in time for this ProductDate. Administrators on PUT/POST Establishing the check-in time reference for arrivals on this ProductDate. <code>checkOutAnchor</code> TimeStamp The temporal anchor defining the check-out time for this ProductDate. Administrators on PUT/POST Establishing the check-out time reference for departures on this ProductDate. <code>noShowAnchor</code> TimeStamp The temporal anchor defining the time after which a reservation for this ProductDate is considered a no-show. Administrators on PUT/POST Establishing the reference time for determining no-shows for arrivals this ProductDate."},{"location":"datatypes/product-dates/#productdatepartypolicyref","title":"ProductDatePartyPolicyRef","text":"<p>A ProductDatePartyPolicyRef defines a reference to a party policy that governs how parties are managed for this particular ProductDate. A ProductDatePartyPolicyRef will fully resolve rules that apply at the ProductDate level.</p> <p>The related PartyPolicy is exclusively applied to this ProductDate when enforcing party rules. Therefore, the primary key of the PartyPolicy can be inferred.</p> property type description derived from evaluated when <code>partyCompositionRules</code> PartyCompositionRules The rules governing what types of party members/equipment can be included in a booking and what the minimum and maximum value for each type of party member/equipment is for this ProductDate. Administrators on PUT/POST Determining the rules for how parties can be composed for bookings of this ProductDate."},{"location":"datatypes/product-dates/#productdatefeepolicyref","title":"ProductDateFeePolicyRef","text":"<p>A ProductDateFeePolicyRef defines a reference to a fee policy that governs how fees are applied to bookings of this particular ProductDate. A ProductDateFeePolicyRef will fully resolve rules that apply at the ProductDate level.</p> <p>The related FeePolicy is exclusively applied to this ProductDate when enforcing fee rules. Therefore, the primary key of the FeePolicy can be inferred.</p> <p>LineItems only need to be present on the ProductDate if the system is to provide a ProductDate-level fee estimate prior to booking. Otherwise, they can remain on the exclusive FeePolicy to be resolved at reservation time.</p> property type description derived from evaluated when <code>feeSchedule</code> [FeeDefinition] The fee schedule that defines how fees are calculated for reservations of this ProductDate. Administrators on PUT/POST Determining the fee structure and amounts that apply to bookings of this ProductDate. <code>lineItems</code> [LineItem] The line items that define specific fee calculations for this ProductDate. Administrators on PUT/POST Defining how fees are calculated and applied to bookings of this ProductDate."},{"location":"datatypes/product-dates/#productdatechangepolicyref","title":"ProductDateChangePolicyRef","text":"<p>A ProductDateChangePolicyRef defines a reference to a change policy that governs how changes/refunds are handled for this particular ProductDate. A ProductDateChangePolicyRef will fully resolve rules that apply at the ProductDate level.</p> <p>The related ChangePolicy is exclusively applied to this ProductDate when enforcing change/refund rules. Therefore, the primary key of the ChangePolicy can be inferred.</p> property type description derived from evaluated when <code>temporalWindows</code> ProductDateChangeTemporalWindows The temporal windows that govern when changes/refunds can be made for this ProductDate. Administrators on PUT/POST Enforcing time-based rules for when changes/refunds can be made for this ProductDate."},{"location":"datatypes/product-dates/#productdatechangetemporalwindows","title":"ProductDateChangeTemporalWindows","text":"property type description derived from evaluated when <code>changeWindow</code> ResolvedTemporalWindow The temporal window during which changes/refunds can be made for this ProductDate. Administrators on PUT/POST Enforcing the time period when changes/refunds can be made for this ProductDate. <code>cancellationWindow</code> ResolvedTemporalWindow The temporal window during which changes/refunds can be made for this ProductDate. Administrators on PUT/POST Enforcing the time period when changes/refunds can be made for this ProductDate. <pre><code>{\n  \"pk\": \"productDate::mockPark1::backcountryCamp::1:1\",\n  \"sk\": \"2026-02-09\",\n  \"gsi1pk\": \"\",\n  \"gsi1sk\": \"\",\n  \"schema\": \"productDate\",\n  \"globalId\": \"c7e8b2e3-4f2a-4b8a-9d3a-8a1e5f7c2b6d\",\n  \"collectionId\": \"mockPark1\",\n  \"activityType\": \"backcountryCamp\",\n  \"activityId\": \"1\",\n  \"productId\": \"1\",\n  \"date\": \"2026-02-09\",\n  \"displayName\": \"Mock Backcountry Camping Offering for Mock Park 1 on February 9, 2026\",\n  \"description\": \"Mock backcountry camping reservation for Mock Park 1 on February 9, 2026.\",\n  \"availabilitySignal\": {\n    \"pk\": \"availabilitySignal::mockPark1::backcountryCamp::1:1\",\n    \"sk\": \"2026-02-09\"\n  },\n  \"allDatesBookedIntervalIds\": [],\n  \"assetList\": [\n    {\n      \"primaryKey\": {\n        \"pk\": \"asset::mockPark1::campground::1\",\n        \"sk\": \"campsite::1\"\n      },\n      \"allocationType\": \"fixed\",\n      \"quantity\": 1\n    },\n    {\n      \"primaryKey\": {\n        \"pk\": \"asset::mockPark1::campground::1\",\n        \"sk\": \"campsite::2\"\n      },\n      \"allocationType\": \"fixed\",\n      \"quantity\": 1\n    },\n    {\n      \"primaryKey\": {\n        \"pk\": \"asset::mockPark1::campground::1\",\n        \"sk\": \"campsite::3\"\n      },\n      \"allocationType\": \"fixed\",\n      \"quantity\": 1\n    }\n  ],\n  \"reservationPolicy\": {\n    \"isDiscoverable\": true,\n    \"isReservable\": true,\n    \"minDailyInventory\": 1,\n    \"maxDailyInventory\": 1,\n    \"temporalAnchors\": {\n      \"checkInAnchor\": \"2026-02-09T14:00:00-08:00\",\n      \"checkOutAnchor\": \"2026-02-10T11:00:00-08:00\",\n      \"noShowAnchor\": \"2026-02-09T23:59:59-08:00\"\n    },\n    \"temporalWindows\": {\n      \"discoveryWindow\": {\n        \"open\": \"2026-01-01T07:00:00-08:00\",\n        \"close\": \"2026-12-31T23:59:59-08:00\"\n      },\n      \"reservationWindow\": {\n        \"open\": \"2026-01-26T07:00:00-08:00\",\n        \"close\": \"2026-02-08T23:59:59-08:00\"\n      },\n      \"restrictedBookingWindow\": {\n        \"open\": \"2026-01-26T07:00:00-08:00\",\n        \"close\": \"2026-01-27T07:00:00-08:00\"\n      }\n    }\n  },\n  \"reservationContext\": {\n    \"discoveryWindow\": {\n      \"open\": \"2026-01-01T07:00:00-08:00\",\n      \"close\": \"2026-12-31T23:59:59-08:00\"\n    },\n    \"reservationWindow\": {\n      \"open\": \"2026-01-26T07:00:00-08:00\",\n      \"close\": \"2026-02-08T23:59:59-08:00\"\n    },\n    \"restrictedBookingWindow\": {\n      \"open\": \"2026-01-26T07:00:00-08:00\",\n      \"close\": \"2026-01-27T07:00:00-08:00\"\n    },\n    \"productDate\": \"2026-02-09\",\n    \"checkInAnchor\": \"2026-02-09T14:00:00-08:00\",\n    \"checkOutAnchor\": \"2026-02-10T11:00:00-08:00\",\n    \"noShowAnchor\": \"2026-02-09T23:59:59-08:00\"\n  },\n  \"feePolicy\": {\n    \"feeSchedule\": [\n      {\n        \"id\": \"tentpadFee\",\n        \"label\": \"Nightly Tent Pad Reservation Fee\",\n        \"type\": \"unit\",\n        \"amount\": 15\n      },\n      {\n        \"id\": \"perAdultFee\",\n        \"label\": \"Nightly Adult Fee\",\n        \"type\": \"unit\",\n        \"amount\": 10\n      },\n      {\n        \"id\": \"perChildFee\",\n        \"label\": \"Nightly Child Fee\",\n        \"type\": \"unit\",\n        \"amount\": 5\n      },\n      {\n        \"id\": \"tax\",\n        \"label\": \"tax\",\n        \"type\": \"percentage\",\n        \"amount\": 0.05\n      }\n    ]\n  },\n  \"lineItems\": [\n    {\n      \"id\": \"tentPadLineItem\",\n      \"label\": \"Tent Pad Fee\",\n      \"type\": \"unit\",\n      \"if\": [],\n      \"quantity\": {\n        \"type\": \"ref\",\n        \"value\": \"inventory.quantity\"\n      },\n      \"rate\": {\n        \"type\": \"ref\",\n        \"value\": \"feeSchedule.tentpadFee\"\n      },\n      \"taxApplied\": [\n        {\n          \"type\": \"ref\",\n          \"value\": \"feeSchedule.tax\"\n        }\n      ],\n      \"discountsApplied\": [],\n      \"isReturnable\": true\n    },\n    {\n      \"id\": \"perAdultLineItem\",\n      \"label\": \"Per Adult Fee\",\n      \"type\": \"unit\",\n      \"if\": [],\n      \"quantity\": {\n        \"type\": \"ref\",\n        \"value\": \"partyContext.adults\"\n      },\n      \"rate\": {\n        \"type\": \"ref\",\n        \"value\": \"feeSchedule.perAdultFee\"\n      },\n      \"taxApplied\": [\n        {\n          \"type\": \"ref\",\n          \"value\": \"feeSchedule.tax\"\n        }\n      ],\n      \"discountsApplied\": [],\n      \"isReturnable\": true\n    },\n    {\n      \"id\": \"perChildLineItem\",\n      \"label\": \"Per Child Fee\",\n      \"type\": \"unit\",\n      \"if\": [],\n      \"quantity\": {\n        \"type\": \"ref\",\n        \"value\": \"partyContext.children\"\n      },\n      \"rate\": {\n        \"type\": \"ref\",\n        \"value\": \"feeSchedule.perChildFee\"\n      },\n      \"taxApplied\": [\n        {\n          \"type\": \"ref\",\n          \"value\": \"feeSchedule.tax.amount\"\n        }\n      ],\n      \"discountsApplied\": [],\n      \"isReturnable\": true\n    }\n  ],\n  \"creationDate\": \"2026-01-01T12:00:00-08:00\",\n  \"lastUpdated\": \"2026-01-01T12:00:00-08:00\",\n  \"version\": 1\n}\n</code></pre>"},{"location":"datatypes/products/","title":"Product","text":"<p>A product is a specific, governed instance of an activity - they are what BC Parks 'offers' to match a visitor's wants. Products are coupled closely with ProductDates, which resolve how the Product experience is offered on a specific calendar day. Products act as the general definition of an offering, while ProductDates act as the time-specific execution of that offering. Products provide the structure, identity, and administrative control needed to generate ProductDates, which in turn influence and manage availability, bookings, and day-specific operations.</p> <p>For example, a Product might be \"Backcountry Camping on the Bedwell Lakes Trail - 2026 Season\", which defines the general offering and rules for that offering, while each ProductDate seeded from that Product would represent the execution of that offering on a specific date (e.g., \"Backcountry Camping on the Bedwell Lakes Trail on May 1st, 2026\").</p>"},{"location":"datatypes/products/#product-assertions","title":"Product Assertions","text":"<ul> <li>Each Product must have a unique combination of <code>collectionId</code>, <code>activityType</code>, <code>activityId</code>, and <code>productId</code> to ensure distinct offerings within the same activity context.</li> <li>For each Product, at most one ProductDate will be created for each date in the Product's defined date range. ProductDates inherit many rules and policies from their parent Product, but also have the ability to override certain aspects to accommodate day-specific needs.</li> <li>In cases where the rules of a Product must change on a more frequent cadence than daily, multiple Products should be created to represent these variations, each with their own date ranges and associated ProductDates. Example: AM and PM trail pass offerings for the same trail on the same day would be represented as two separate Products, each with their own ProductDates for that day.</li> <li>On dates where no ProductDate exists for a Product, the Product is effectively inactive and cannot be booked on that date.</li> </ul>"},{"location":"datatypes/products/#products-vs-activities","title":"Products vs. Activities","text":"<p>Activities and Products may appear similar at first glance - they both describe something a visitor can do, but they serve fundamentally different roles in the system. Keeping them separate preserves clarity in the discovery experience, stability in the data model, and flexibility in how offerings evolve over time.</p> <p>Activities describe the place-anchored idea of an experience. They are discoverable at all times, so that site visitors can see the potential experiences that are associated with a specific place, essentially showing 'what the place is known for', even if it is not currently reservable.</p> <p>Products turn the idea of an Activity into one or more reservable offerings. They are not always discoverable - typically only when they are being offered - and come complete with the governing rules that enable the site visitor to actually obtain the experience described by the Activity.</p> <p>If an Activity is the 'experience', the Product is the 'offering' visitors can obtain to get their desired experience.</p>"},{"location":"datatypes/products/#products-as-booking-governance-modules","title":"Products as Booking Governance Modules","text":"<p>Products encapsulate the key governance elements that define how an offering is made available to visitors. Governance elements (policies) that apply at the Product level of scope include:</p> <ul> <li>Discoverability rules (e.g., when the offering appears in search results)</li> <li>Minimum/maximum total days for reservations of this Product</li> <li>Which Assets are allocated to this Product and how they are allocated (e.g., fixed vs. flex)</li> <li>Itinerary rules (e.g., entry/exit points, overnight stays)</li> <li>Fee policies that define how fees are calculated at the Product level</li> <li>Other high-level rules that apply to the offering as a whole, or that cannot vary on a per-day basis.</li> </ul> <p>The Product also defines the date range over which ProductDates will be created, and provides the template from which those ProductDates inherit their initial rules and policies.</p>"},{"location":"datatypes/products/#properties","title":"Properties","text":""},{"location":"datatypes/products/#product_1","title":"Product","text":"property type description derived from evaluated when <code>pk</code> String Partition key product::<code>collectionId</code>::<code>activityType</code>::<code>activityId</code> Searching for all Products related to a specific Activity. <code>sk</code> String Sort key <code>productId</code> Searching for a specific Product related to a specific Activity <code>gsipk?</code> String Global secondary index partition key Reserved Reserved <code>gsisk?</code> String Global secondary index sort key Reserved Reserved <code>schema</code> String Data type/Schema \"product\" Identifying that this item is a \"product\" <code>globalId</code> String Globally unique UUID Automatically generating on Product POST Searching for this specific item using the <code>globalId</code> GSI <code>collectionId</code> String The identifier of the collection this Product belongs to Parent Activity's <code>collectionId</code> Determining which collection this Product belongs to <code>productId</code> Number Uniquely identifies this Product from other Products with the same partition key Automatically generating  on Product POST Distinguishing this Product from other Products with the same partition key <code>identifier</code> Number Uniquely identifies this item from other items with the same partition key (similar to <code>productId</code>) Copying <code>productId</code> Distinguishing this item from other items with the same partition key <code>activityType</code> String The type of activity this Product offers Parent Activity's <code>activityType</code> Determining what type of Activity this product offers <code>activityId</code> Number The unique identifier of the parent Activity Parent Activity's <code>activityId</code> Determining which specific Activity of <code>activityType</code> within the <code>collectionId</code> that this Product refers to <code>activitySubType?</code> String A further categorization of the type of Activity this Product offers, if available Parent Activity's <code>activitySubType</code> Determining what type of <code>activitySubType</code> this Product offers <code>displayName</code> String A human-readable name for this Product. Administrators on PUT/POST Providing a public facing, human-readable title of the offering captured by this Product <code>description</code> String Descriptive text explaining the operational meaning of this Product Administrators on PUT/POST Providing a public facing, human-readable description of the offering captured by this Product. <code>timezone</code> String IANA timezone identifier for the location where this Product is offered Administrators on PUT/POST Determining the timezone context for date and time calculations related to this Product <code>rangeStart</code> Date First date in the range of date this Product enables Administrators on PUT/POST Determining the date before which no child <code>productDates</code> will be generated on ProductDate seed <code>rangeEnd</code> Date Last date in the range of date this Product enables Administrators on PUT/POST Determining the date after which no child <code>productDates</code> will be generated on ProductDate seed <code>assetList</code> [AssetRef] A list of assets associated with the product Administrators on PUT/POST Determining which assets are allocated through this offering <code>availabilityEstimationPattern</code> AvailabilityEstimationPattern Pattern governing how availability is estimated for ProductDates related to this Product Administrators on PUT/POST Determining how availability is estimated for ProductDates related to this Product <code>itineraryRules?</code> ItineraryRules Rules governing how itineraries are validated for bookings of this Product Administrators on PUT/POST Determining how itineraries are validated for bookings of this Product <code>waitRoomConfig</code> WaitRoomConfig Configuration for wait room behavior for this Product (future consideration) Administrators on PUT/POST Determining how to handle excess demand for bookings of this Product <code>allDatesReservedIntervals?</code> [DateInterval] An array of date intervals representing periods of time where a Booking must contain all DateInterval dates if one date touches the DateInterval Administrators on PUT/POST Determining if a booking of this Product must contain all dates within any of the defined date intervals if one of the dates in the booking touches any of the dates in the date interval <code>reservationPolicy</code> ProductReservationPolicyRef Reference to the reservation policy that governs reservations of this Product Administrators on PUT/POST Determining which reservation policy applies to reservations of this Product <code>partyPolicy</code> ProductPartyPolicyRef Reference to the booking policy that governs bookings of this Product Administrators on PUT/POST Determining which booking policy applies to bookings of this Product <code>feePolicy</code> ProductFeePolicyRef Reference to the fee policy that governs fees associated with this Product Administrators on PUT/POST Determining which fee policy applies to bookings of this Product <code>changePolicy</code> ProductChangePolicyRef Reference to the change policy that governs changes/refunds for this Product Administrators on PUT/POST Determining which change policy applies to changes/refunds for this Product <code>creationDate</code> String ISO 8601 timestamp of when this item was created Administrators on POST Determining when this item was created <code>lastUpdated</code> String ISO 8601 timestamp of when this item was last updated Administrators on PUT/POST Determining when this item was last updated <code>version</code> Number Version number for optimistic locking Automatically incremented on PUT/POST Ensuring that updates to this item do not overwrite more recent changes made by other processes"},{"location":"datatypes/products/#assetref","title":"AssetRef","text":"<p>An AssetRef defines a reference to an asset and the quantity of that asset allocated to a Product. A Products <code>assetList</code> is an array of AssetRefs.</p> property type description derived from evaluated when <code>primaryKey</code> PrimaryKey The primary key of the referenced Asset Administrators on PUT/POST Identifying which Asset is being referenced <code>assetType?</code> String The type of the referenced Asset (e.g., \"campsite\", \"boat slip\") Referenced Asset Determining the type of the referenced Asset <code>allocationType</code> String The type of allocation for this Asset within the Product (e.g., \"fixed\", \"flex\") Referenced Asset Determining how the referenced Asset is allocated to this Product <code>quantity</code> Number The quantity of the referenced Asset allocated to this Product Administrators on Product PUT/POST Determining how many units of the referenced Asset are allocated to this Product (will be 1 in \"fixed\" cases, and a base-level capacity in \"flex\" cases)"},{"location":"datatypes/products/#itineraryrules","title":"ItineraryRules","text":"<p>ItineraryRules define the rules governing how itineraries are collected for the Product. Some offerings may require entry and exit points, expected locations for overnight stays, or both. This is particularly relevant for activities such as multi-day hiking or boating trips - but the information collected is primarily used for informational purposes and visitor safety (SAR) and does not impact availability or inventory management.</p> property type description derived from evaluated when <code>entryExit</code> AccessPointRules Rules governing entry and exit points for itineraries Administrators on Product PUT/POST Determining how entry and exit points are managed for Bookings of this Product <code>stayPoints</code> OvernightStayRules Rules governing overnight stays for itineraries Administrators on Product PUT/POST Determining how overnight stays are managed for Bookings of this Product"},{"location":"datatypes/products/#accesspointrules","title":"AccessPointRules","text":"property type description derived from evaluated when <code>required</code> Boolean Whether entry and exit points are required for itineraries Administrators on Product PUT/POST Determining if entry and exit points must be specified for Bookings of this Product <code>allowedEntryPoints?</code> [PrimaryKey] List of allowed Facility primary keys to be used as entry points Administrators on Product PUT/POST Determining which Facilities are allowed as entry points for Bookings <code>allowedExitPoints?</code> [PrimaryKey] List of allowed Facility primary keys to be used as exit points Administrators on Product PUT/POST Determining which Facilities are allowed as exit points for Bookings"},{"location":"datatypes/products/#overnightstayrules","title":"OvernightStayRules","text":"property type description derived from evaluated when <code>required</code> Boolean Whether overnight stays are required for itineraries Administrators on Product PUT/POST Determining if overnight stays must be specified for Bookings of this Product <code>allowedStayPoints?</code> [PrimaryKey] List of allowed Facility primary keys to be used as overnight stay points Administrators on Product PUT/POST Determining which Facilities are forwarded to each ProductDate on seeding to populate the overnight stay points"},{"location":"datatypes/products/#waitroomconfig","title":"WaitRoomConfig","text":"<p>Future consideration.</p>"},{"location":"datatypes/products/#dateinterval","title":"DateInterval","text":"<p>A DateInterval defines a group of dates. If a booking touches any of the dates in the DateInterval, the booking must include all of the dates in the DateInterval. This is used to enforce rules such as \"if a visitor books May 1st, they must also book May 2nd and May 3rd\" for a Product that has an allDatesBookedInterval that includes May 1st, May 2nd, and May 3rd.</p> property type description derived from evaluated when <code>id</code> String Unique identifier for the date interval Administrators on Product PUT/POST Distinguishing this date interval from others in the same Product <code>label</code> String The label for this date interval (e.g., \"May Long Weekend\") Administrators on Product PUT/POST Providing a human-readable label for this date interval <code>startDate</code> Date The first date in the date interval Administrators on Product PUT/POST Determining the start date of the date interval <code>endDate</code> Date The last date in the date interval Administrators on Product PUT/POST Determining the end date of the date interval"},{"location":"datatypes/products/#productreservationpolicyref","title":"ProductReservationPolicyRef","text":"<p>A ProductReservationPolicyRef defines a reference to a reservation policy that governs how reservations are made for a Product. A reservation policy will include rules that apply at the Product level, and rules that will be inherited by each ProductDate created for the Product. A ProductReservationPolicyRef will fully resolve rules that apply at the Product level, and will include a reference to the ReservationPolicy for for rules that will be applied at the ProductDate level when seeding.</p> property type description derived from evaluated when <code>primaryKey</code> PrimaryKey The primary key of the referenced Reservation Policy Administrators on PUT/POST Identifying which Reservation Policy is being referenced for this Product <code>isDiscoverable</code> Boolean Whether this Product is discoverable for reservation searches. If true, the <code>discoveryWindow</code> is used to determine discoverability. If false, the Product cannot be discovered. Referenced Reservation Policy Determining if this Product appears in reservation search results <code>isReservable</code> Boolean Whether this Product can be reserved. If true, ProductDates can be queried for this Product. If false, the Product cannot be reserved. Referenced Reservation Policy Determining if this Product can be reserved <code>minTotalDays</code> Number Minimum total days for reservations of this Product Referenced Reservation Policy Enforcing minimum total days for reservations of this Product <code>maxTotalDays</code> Number Maximum total days for reservations of this Product Referenced Reservation Policy Enforcing maximum total days for reservations of this Product <code>holdDuration</code> Duration The length of time that a reservation of this Product can be held in a cart before it expires Referenced Reservation Policy Enforcing cart duration for reservations of this Product <code>temporalWindows</code> ProductReservationTemporalWindows Temporal windows governing reservation availability for this Product Referenced Reservation Policy Enforcing temporal windows for reservations of this Product"},{"location":"datatypes/products/#productreservationtemporalwindows","title":"ProductReservationTemporalWindows","text":"property type description derived from evaluated when <code>discoveryWindow</code> ResolvedTemporalWindow The discovery window for this Product. Referenced Reservation Policy Enforcing the discovery window for this Product"},{"location":"datatypes/products/#resolvedtemporalwindow","title":"ResolvedTemporalWindow","text":"property type description derived from evaluated when <code>open</code> Timestamp The opening timestamp of the temporal window Referenced Temporal Window Enforcing the opening timestamp of the temporal window <code>close</code> Timestamp The closing timestamp of the temporal window Referenced Temporal Window Enforcing the closing timestamp of the temporal window"},{"location":"datatypes/products/#productpartypolicyref","title":"ProductPartyPolicyRef","text":"<p>A ProductPartyPolicyRef defines a reference to a party policy that governs how Inventory can be consumed once reserved. A party policy will include rules that apply at the Product level, and rules that will be inherited by each ProductDate created for the Product. A ProductPartyPolicyRef will fully resolve rules that apply at the Product level, and will include a reference to the PartyPolicy for rules that will be applied at the ProductDate level when seeding.</p> property type description derived from evaluated when <code>primaryKey</code> PrimaryKey The primary key of the referenced Party Policy Administrators on PUT/POST Identifying which Party Policy is being referenced for this Product"},{"location":"datatypes/products/#productfeepolicyref","title":"ProductFeePolicyRef","text":"<p>A ProductFeePolicyRef defines a reference to a fee policy that governs how fees are applied to bookings of a Product. A fee policy will include rules that apply at the Product level, and rules that will be inherited by each ProductDate created for the Product. A ProductFeePolicyRef will fully resolve rules that apply at the Product level, and will include a reference to the FeePolicy for for rules that will be applied at the ProductDate level when seeding.</p> property type description derived from evaluated when <code>primaryKey</code> PrimaryKey The primary key of the referenced Fee Policy Administrators on Product PUT/POST Identifying which Fee Policy is being referenced for this Product <code>feeSchedule?</code> [feeDefinition] The fee schedule associated with this Product Referenced Fee Policy Determining which fee components are used in the Product-level line items of this Product <code>lineItems?</code> [LineItem] The line items associated with this Product Referenced Fee Policy Determining how this Product is charged for at a Product level"},{"location":"datatypes/products/#productchangepolicyref","title":"ProductChangePolicyRef","text":"<p>A ProductChangePolicyRef defines a reference to a change policy that governs how changes/refunds are handled for a Product. A change policy will include rules that apply at the Product level, and rules that will be inherited by each ProductDate created for the Product. A ProductChangePolicyRef will fully resolve rules that apply at the Product level, and will include a reference to the ChangePolicy for rules that will be applied at the ProductDate level when seeding.</p> property type description derived from evaluated when <code>primaryKey</code> PrimaryKey The primary key of the referenced Change Policy Administrators on Product PUT/POST Identifying which Change Policy is being referenced for this Product <code>rules</code> [ChangePolicyRule] The change/refund rules that apply to this Product Referenced Change Policy Determining how changes and refunds are handled for this Product"},{"location":"datatypes/products/#changepolicyrule","title":"ChangePolicyRule","text":"<p>Returns will only be processed if the change request falls within the temporal window defined in the rule, and if any conditions defined in the <code>if</code> property are met. None of rules can have temporal windows that overlap. If a change request does not meet the conditions of any of the rules, it will be rejected.</p> property type description derived from evaluated when <code>id</code> String Unique identifier for the change policy rule Administrators on ChangePolicy PUT/POST Distinguishing this change policy rule from others in the same change policy <code>label</code> String Human-readable label for the change policy rule Administrators on ChangePolicy PUT/POST Providing a public facing, human-readable title of this change policy rule <code>type</code> String The type of refund applied in this rule (e.g. \"flat\", \"percentage\") Administrators on ChangePolicy PUT/POST Determining how refunds are calculated when this rule is applied <code>amount</code> Number The base amount used in calculating refunds for this rule Administrators on ChangePolicy PUT/POST Determining the base amount used in calculating refunds when this rule is applied <code>if</code> [ComparisonPrimitive] Optional conditions that must be met for this change policy rule to be applied Administrators on ChangePolicy PUT/POST Determining if this change policy rule should be applied based on booking context <code>temporalWindow</code> ResolvedTemporalWindow A temporal window that determines when this change policy rule is applied based on the timing of the change request Administrators on ChangePolicy PUT/POST Determining if this change policy rule should be applied based on the timing of the change request"},{"location":"datatypes/products/#example-product","title":"Example Product","text":"<p>Below is an example of a ficticious Product item that might be stored in the database. This example represents a backcountry camping offering for a specific park (Mock Park 1) for the 2026 season. It encodes the following details:</p> <ul> <li>The Product is associated with the \"backcountryCamp\" activity type and has a unique productId of 1 within that activity context.</li> <li>The Product will generate ProductDates (and therefore be support offerings) from May 1st to October 31st, 2026, and is in the \"America/Vancouver\" IANA timezone.</li> <li>The Product allocates 3 specific campsites (campsite 1, 2, and 3 in campground 1 of Mock Park 1) as fixed assets for this offering.</li> <li>The Product uses an availability estimation pattern that provides exact availability estimates every 5 minutes.</li> <li>The itinerary rules require entry and exit points, allowing accessPoint 1 and 2 of Mock Park 1 as valid options, and require overnight stays with allowed stay points at campground 1 and 2 of Mock Park 1.</li> <li>The Product references a reservation policy that makes it discoverable and reservable, with a minimum total days of 1 and a maximum total days of 14, and a discovery window from January 1st to December 31st, 2026.</li> <li>The Product references a booking policy that will be inherited by seeded ProductDates.</li> <li>The Product references a fee policy that includes a fee schedule with a flat transaction fee of $6.5 and a tax of 5%, and a line item that applies the transaction fee and associated tax to the Product at a Product level.</li> <li>The Product references a change policy that will be inherited by seeded ProductDates.</li> </ul> <pre><code>{\n  \"pk\": \"product::mockPark1::backcountryCamp::1\",\n  \"sk\": \"1\",\n  \"schema\": \"product\",\n  \"globalId\": \"73a8b2c1-4d5e-6f7a-8b9c-0d1e2f3a4b5c\",\n  \"collectionId\": \"mockPark1\",\n  \"productId\": 1,\n  \"identifier\": 1,\n  \"activityType\": \"backcountryCamp\",\n  \"activityId\": 1,\n  \"activitySubType\": null,\n  \"displayName\": \"Mock Backcountry Camping Offering for Mock Park 1 - 2026 Season\",\n  \"description\": \"Mock backcountry camping reservation for Mock Park 1 for the 2026 season.\",\n  \"rangeStart\": \"2026-05-01\",\n  \"rangeEnd\": \"2026-10-31\",\n  \"timezone\": \"America/Vancouver\",\n  \"assetList\": [\n    {\n      \"primaryKey\": {\n        \"pk\": \"asset::mockPark1::campground::1\",\n        \"sk\": \"campsite::1\"\n      },\n      \"allocationType\": \"fixed\",\n      \"quantity\": 1\n    },\n    {\n      \"primaryKey\": {\n        \"pk\": \"asset::mockPark1::campground::1\",\n        \"sk\": \"campsite::2\"\n      },\n      \"allocationType\": \"fixed\",\n      \"quantity\": 1\n    },\n    {\n      \"primaryKey\": {\n        \"pk\": \"asset::mockPark1::campground::1\",\n        \"sk\": \"campsite::3\"\n      },\n      \"allocationType\": \"fixed\",\n      \"quantity\": 1\n    }\n  ],\n  \"availabilityEstimationPattern\": {\n    \"estimationMode\": \"exact\",\n    \"cadence\": {\n      \"minutes\": 5\n    }\n  },\n  \"itineraryRules\": {\n    \"entryExit\": {\n      \"required\": true,\n      \"allowedEntryPoints\": [\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::1\"\n        },\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::2\"\n        }\n      ],\n      \"allowedExitPoints\": [\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::1\"\n        },\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"accessPoint::2\"\n        }\n      ]\n    },\n    \"stayPoints\": {\n      \"required\": true,\n      \"allowedStayPoints\": [\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"campground::1\"\n        },\n        {\n          \"pk\": \"facility::mockPark1\",\n          \"sk\": \"campground::2\"\n        }\n      ]\n    }\n  },\n  \"waitRoomConfig\": {},\n  \"allDatesReservedIntervals\": [\n    {\n      \"id\": \"mayLong2026\",\n      \"displayName\": \"May Long Weekend 2026\",\n      \"startDate\": \"2026-05-15\",\n      \"endDate\": \"2026-05-18\"\n    }\n  ],\n  \"reservationPolicy\": {\n    \"primaryKey\": {\n      \"pk\": \"policy::reservation::101\",\n      \"sk\": \"v1\"\n    },\n    \"isDiscoverable\": true,\n    \"isReservable\": true,\n    \"minTotalDays\": 1,\n    \"maxTotalDays\": 14,\n    \"temporalWindows\": {\n      \"discoveryWindow\": {\n        \"open\": \"2026-01-01T07:00:00-08:00\",\n        \"close\": \"2026-12-31T23:59:59-08:00\"\n      }\n    }\n  },\n  \"reservationContext\": {\n    \"discoveryWindow\": {\n      \"open\": \"2026-01-01T07:00:00-08:00\",\n      \"close\": \"2026-12-31T23:59:59-08:00\"\n    }\n  },\n  \"partyPolicy\": {\n    \"primaryKey\": {\n      \"pk\": \"policy::party::101\",\n      \"sk\": \"v1\"\n    },\n    \"partyCategories\": [\n      {\n        \"id\": \"adults\",\n        \"label\": \"Adults (18+)\",\n        \"minCount\": 1,\n        \"maxCount\": 4\n      },\n      {\n        \"id\": \"children\",\n        \"label\": \"Children &lt;18\",\n        \"minCount\": 0,\n        \"maxCount\": 3\n      },\n      {\n        \"id\": \"tents\",\n        \"label\": \"Tents\",\n        \"minCount\": 1,\n        \"maxCount\": 2\n      }\n    ],\n    \"partyCompositionRules\": [\n      {\n        \"id\": \"maxTotalPartySize\",\n        \"label\": \"Maximum Total Party Size\",\n        \"failMsg\": \"Total party size cannot exceed 4 people.\",\n        \"if\": [],\n        \"then\": {\n          \"lhs\": [\n            {\n              \"type\": \"ref\",\n              \"value\": \"partyContext.adults\"\n            },\n            {\n              \"op\": \"add\"\n            },\n            {\n              \"type\": \"ref\",\n              \"value\": \"partyContext.children\"\n            }\n          ],\n          \"op\": \"lte\",\n          \"rhs\": [\n            {\n              \"type\": \"constant\",\n              \"value\": 4\n            }\n          ]\n        }\n      }\n    ]\n  },\n  \"feePolicy\": {\n    \"primaryKey\": {\n      \"pk\": \"policy::fee::301\",\n      \"sk\": \"v1\"\n    },\n    \"feeSchedule\": [\n      {\n        \"id\": \"transactionFee\",\n        \"label\": \"Transaction Fee\",\n        \"type\": \"flat\",\n        \"amount\": 6.5\n      },\n      {\n        \"id\": \"tax\",\n        \"label\": \"Tax\",\n        \"type\": \"percentage\",\n        \"amount\": 0.05\n      }\n    ],\n    \"lineItems\": [\n      {\n        \"id\": \"transactionFeeLine\",\n        \"label\": \"Transaction Fee\",\n        \"type\": \"flat\",\n        \"isReturnable\": false,\n        \"if\": [],\n        \"quantity\": {\n          \"type\": \"constant\",\n          \"value\": 1\n        },\n        \"rate\": {\n          \"type\": \"ref\",\n          \"value\": \"feeSchedule.transactionFee.amount\"\n        },\n        \"taxApplied\": [\n          {\n            \"type\": \"ref\",\n            \"value\": \"feeSchedule.tax.amount\"\n          }\n        ],\n        \"discountsApplied\": []\n      }\n    ]\n  },\n  \"changePolicy\": {\n    \"primaryKey\": {\n      \"pk\": \"policy::refund::401\",\n      \"sk\": \"v1\"\n    }\n  },\n  \"createdAt\": \"2024-01-01T12:00:00Z\",\n  \"lastUpdated\": \"2024-01-01T12:00:00Z\",\n  \"version\": 1\n}\n</code></pre>"},{"location":"datatypes/policies/change-policies/","title":"Change Policy","text":"property type description derived from evaluated when <code>pk</code> String Partition key \"policy::\\::\\\" Searching all versions of this policy <code>sk</code> String Sort key \"v\\\" OR \"latest\" Searching for a specific version of this policy <code>gsipk</code> String Global secondary index partition key Reserved Reserved <code>gsisk</code> String Global secondary index sort key Reserved Reserved <code>schema</code> String Data type/Schema \"policy\" Identifying that this item is a \"policy\" <code>globalId</code> String Globally unique UUID Automatically generating on policy creation Searching for this specific item using the <code>globalId</code> GSI <code>policyType</code> String The type of policy \"party\" Searching for all policies of this type <code>policyId</code> String A unique identifier for this policy, specific to the policy type Automatically generating on policy creation Searching for all versions of this specific policy <code>policyIdVersion</code> Number The version number of this policy Automatically incrementing on policy update Searching for a specific version of this policy <code>isLatest</code> Boolean Whether this is the latest version of the policy Automatically setting on policy update Searching for the latest version of this policy <code>displayName</code> String A human-readable name for this policy Provided on policy creation and update Displaying this policy in a user interface <code>description</code> String A human-readable description of this policy Provided on policy creation and update Displaying this policy in a user interface <code>productRules</code> ChangeProductRules The rules that govern how this policy is applied at the Product level Provided on policy creation and update Evaluating whether a Product complies with the rules defined in this policy <code>createdAt</code> Timestamp The timestamp when this policy was created Automatically setting on policy creation Tracking when this policy was created <code>lastUpdated</code> Timestamp The timestamp when this policy was last updated Automatically updating on policy update Tracking when this policy was last updated"},{"location":"datatypes/policies/change-policies/#changeproductrules","title":"ChangeProductRules","text":"property type description derived from evaluated when"},{"location":"datatypes/policies/fee-policies/","title":"Fee Policy","text":"property type description derived from evaluated when <code>pk</code> String Partition key \"policy::\\::\\\" Searching all versions of this policy <code>sk</code> String Sort key \"v\\\" OR \"latest\" Searching for a specific version of this policy <code>gsipk</code> String Global secondary index partition key Reserved Reserved <code>gsisk</code> String Global secondary index sort key Reserved Reserved <code>schema</code> String Data type/Schema \"policy\" Identifying that this item is a \"policy\" <code>globalId</code> String Globally unique UUID Automatically generating on policy creation Searching for this specific item using the <code>globalId</code> GSI <code>policyType</code> String The type of policy \"party\" Searching for all policies of this type <code>policyId</code> String A unique identifier for this policy, specific to the policy type Automatically generating on policy creation Searching for all versions of this specific policy <code>policyIdVersion</code> Number The version number of this policy Automatically incrementing on policy update Searching for a specific version of this policy <code>isLatest</code> Boolean Whether this is the latest version of the policy Automatically setting on policy update Searching for the latest version of this policy <code>displayName</code> String A human-readable name for this policy Provided on policy creation and update Displaying this policy in a user interface <code>description</code> String A human-readable description of this policy Provided on policy creation and update Displaying this policy in a user interface <code>productRules</code> FeeProductRules The rules that govern how this policy is applied at the Product level Provided on policy creation and update Evaluating whether a Product complies with the rules defined in this policy <code>productDateRules</code> FeeProductDateRules The rules that govern how this policy is applied at the ProductDate level Provided on policy creation and update Evaluating whether a ProductDate complies with the rules defined in this policy <code>createdAt</code> Timestamp The timestamp when this policy was created Automatically setting on policy creation Tracking when this policy was created <code>lastUpdated</code> Timestamp The timestamp when this policy was last updated Automatically updating on policy update Tracking when this policy was last updated"},{"location":"datatypes/policies/fee-policies/#feeproductrules","title":"FeeProductRules","text":"property type description derived from evaluated when <code>feeSchedule</code> [FeeDefinition] The snapshot of the fee schedule applied to this Booking at the time of booking Derived from parent Product's referenced Fee Policy at the time of booking Capturing the specific fee schedule for this Booking based on the Product's Fee Policy at the moment it was created <code>lineItems</code> LineItem The snapshot of the fee line items applied to this Booking at the time of booking Derived from parent Product's referenced Fee Policy and client input on Booking POST at the time of booking Capturing the specific fee line items for this Booking based on the Product's Fee Policy and customer input at the moment it was created"},{"location":"datatypes/policies/fee-policies/#feeproductdaterules","title":"FeeProductDateRules","text":"property type description derived from evaluated when <code>feeSchedule</code> [FeeDefinition] The snapshot of the fee schedule applied to this Booking at the time of booking Derived from parent Product's referenced Fee Policy at the time of booking Capturing the specific fee schedule for this Booking based on the Product's Fee Policy at the moment it was created <code>lineItems</code> LineItem The snapshot of the fee line items applied to this Booking at the time of booking Derived from parent Product's referenced Fee Policy and client input on Booking POST at the time of booking Capturing the specific fee line items for this Booking based on the Product's Fee Policy and customer input at the moment it was created"},{"location":"datatypes/policies/fee-policies/#feedefinition","title":"FeeDefinition","text":"<p>A single component of a fee schedule that defines a specific fee that can be applied to bookings of a Product. FeeSchedules are made up of multiple FeeDefinitions.</p> property type description derived from evaluated when <code>id</code> String Unique identifier for the fee component Administrators on FeePolicy PUT/POST Distinguishing this fee component from others in the same fee schedule <code>label</code> String Human-readable label for the fee component Administrators on FeePolicy PUT/POST Providing a public facing, human-readable title of this fee component <code>type</code> String Type of fee (e.g., \"flat\", \"percentage\", \"unit\") Administrators on FeePolicy PUT/POST Determining how this fee component is intended to be utilized <code>amount</code> Number The base amount for the fee component Administrators on FeePolicy PUT/POST Determining the base amount used in calculations for this fee component"},{"location":"datatypes/policies/fee-policies/#lineitem","title":"LineItem","text":"<p>A single line item that defines how a fee is calculated and applied to bookings of a Product. LineItems are made up of multiple calculation steps that reference FeeDefinitions from the FeeSchedule, or other LineItems. When provided as part of a ProductFeePolicyRef, LineItems define how to charge for the Product at a Product level. These line items will be supplemented by additional line items defined at the ProductDate level when seeding.</p> <p>LineItems only need to be present on the Product if the system is to provide a Product-level fee estimate prior to selecting specific dates. Otherwise, they can remain on the FeePolicy to resolved at reservation time.</p> property type description derived from evaluated when <code>id</code> String Unique identifier for the line item Administrators on FeePolicy PUT/POST Distinguishing this line item from others in the same fee policy <code>label</code> String Human-readable label for the line item Administrators on FeePolicy PUT/POST Providing a public facing, human-readable title of this line item <code>type</code> String The type of line item (e.g., \"flat\", \"unit\") Administrators on FeePolicy PUT/POST Determining how this line item is processed in the overall fee calculation <code>role</code> String The role of this line item (e.g., \"total\", \"subTotal\", \"tax\") Administrators on FeePolicy PUT/POST Categorizing this line item for internal processing and reporting <code>tags?</code> [String] Optional tags associated with this line item Administrators on FeePolicy PUT/POST Categorizing or labeling this line item for easier identification and conditional UI rendering <code>if</code> [ComparisonPrimitive] Optional conditions that must be met for this line item to be applied Administrators on FeePolicy PUT/POST Determining if this line item should be applied based on booking context <code>quantity</code> ReferencePrimitive The quantity used in calculating this line item. <code>type = flat</code> means <code>quantity</code> is automatically 1 Administrators on FeePolicy PUT/POST Determining the quantity factor used in calculating this line item <code>rate</code> ReferencePrimitive The rate used in calculating this line item. <code>type = unit</code> means <code>rate</code> is applied per unit Administrators on FeePolicy PUT/POST Determining the rate factor used in calculating this line item <code>taxApplied?</code> [ReferencePrimitive] Optional list of taxes applied to this line item Administrators on FeePolicy PUT/POST Determining which taxes are applied per-unit or flatly to this line item <code>discountsApplied?</code> [ReferencePrimitive] Optional list of discounts applied to this line item Administrators on FeePolicy PUT/POST Determining which discounts are applied per-unit or flatly to this line item <code>isReturnable</code> Boolean Whether this line item is eligible for return/refund Administrators on FeePolicy PUT/POST Determining if this line item can be refunded during a return process"},{"location":"datatypes/policies/fee-policies/#fee-calculation-flow","title":"Fee Calculation Flow","text":"<pre><code>---\nconfig:\n  flowchart:\n    curve: basis\n    rankSpacing: 50\n    nodeSpacing: 50\n---\n\nflowchart TD\n\nA[Booking is created or updated] --&gt; B[Snapshot of resolved fee rules taken at both Booking and BookingDate levels] --&gt; C[Look at the first BookingDate]\nC --&gt; D{Does this BookingDate have any fees defined?}\nD --&gt;|Yes| E[Look at the first line item]\nD --&gt;|No| S[Skip to next BookingDate, or if no more BookingDates, look at the Booking as a whole]\nE --&gt; F{Does this line item have an `if` condition?}\nF --&gt;|Yes| G[Evaluate the `if` condition based on the context of the booking and booking date]\nG --&gt; H{Is the condition met?}\nH --&gt;|No| I[Skip this line item and move to the next one] --&gt; F\nH --&gt;|Yes| J[Evaluate one unit of this line item based on its quantity &amp; rate]\nJ --&gt; K{Are there unit discounts to apply?}\nK --&gt;|Yes| L[Apply discounts to this unit]\nK --&gt;|No| M\nL --&gt; M{Are there taxes to apply?}\nM --&gt;|Yes| N[Apply taxes to this unit]\nM --&gt;|No| O\nN --&gt; O[Are there more units to evaluate for this line item?]\nO --&gt;|Yes| J\nO --&gt;|No| Q[Store line item subtotal, taxes, and total]\nQ --&gt; P{Are there more line items to evaluate for this item?}\nP --&gt;|Yes| pp[Look at the next item] --&gt; F\nP --&gt;|No| R[Store subtotal, taxes and total for this item]\nR --&gt; S{Are there more BookingDates to evaluate?}\nS --&gt;|Yes| ss[Look at the next BookingDate] --&gt; D\nS --&gt;|No| T[BookingDate fee calculation is complete with a final total for each BookingDate]\nT --&gt; U[Look at the Booking as a whole]\nU --&gt; V{Are there Booking-level line items to evaluate?}\nV --&gt;|Yes| E\nV --&gt;|No| W[Store Booking-level subtotal, taxes, and total]\nW --&gt; X[Add up all BookingDate totals and Booking totals, store overall subtotal, taxes, and grand total for the Booking]\nX --&gt; Y[Forward the final fee calculation results to the Booking for use in downstream processes like payment and customer communication]\n\n</code></pre>"},{"location":"datatypes/policies/party-policies/","title":"Party Policy","text":"property type description derived from evaluated when <code>pk</code> String Partition key \"policy::\\::\\\" Searching all versions of this policy <code>sk</code> String Sort key \"v\\\" OR \"latest\" Searching for a specific version of this policy <code>gsipk</code> String Global secondary index partition key Reserved Reserved <code>gsisk</code> String Global secondary index sort key Reserved Reserved <code>schema</code> String Data type/Schema \"policy\" Identifying that this item is a \"policy\" <code>globalId</code> String Globally unique UUID Automatically generating on policy creation Searching for this specific item using the <code>globalId</code> GSI <code>policyType</code> String The type of policy \"party\" Searching for all policies of this type <code>policyId</code> String A unique identifier for this policy, specific to the policy type Automatically generating on policy creation Searching for all versions of this specific policy <code>policyIdVersion</code> Number The version number of this policy Automatically incrementing on policy update Searching for a specific version of this policy <code>isLatest</code> Boolean Whether this is the latest version of the policy Automatically setting on policy update Searching for the latest version of this policy <code>displayName</code> String A human-readable name for this policy Provided on policy creation and update Displaying this policy in a user interface <code>description</code> String A human-readable description of this policy Provided on policy creation and update Displaying this policy in a user interface <code>refStore</code> ReferenceStore The reference store that contains any additional data needed to evaluate this policy Provided on policy creation and update Accessing additional data needed to evaluate this policy <code>productRules</code> PartyProductRules The rules that govern how this policy is applied at the Product level Provided on policy creation and update Evaluating whether a Product complies with the rules defined in this policy <code>createdAt</code> Timestamp The timestamp when this policy was created Automatically setting on policy creation Tracking when this policy was created <code>lastUpdated</code> Timestamp The timestamp when this policy was last updated Automatically updating on policy update Tracking when this policy was last updated"},{"location":"datatypes/policies/party-policies/#partyproductrules","title":"PartyProductRules","text":"property type description derived from evaluated when <code>partyCategories</code> [PartyCategory] The rules governing what types of party members/equipment can be included in a booking and what the minimum and maximum value for each type of party member/equipment is Provided on policy creation and update Evaluating whether a Product complies with the party composition rules defined in this policy <code>partyCompositionRules</code> [ElegibilityPrimitive] The rules governing what combinations of party members/equipment can be included in a booking Provided on policy creation and update Evaluating whether a Product complies with the party composition rules defined in this policy"},{"location":"datatypes/policies/party-policies/#partycategory","title":"PartyCategory","text":"property type description derived from evaluated when <code>id</code> String The unique identifier for this party category Derived from parent Product's Party Policy Identifying this specific party category <code>label</code> String The display name for this party category Derived from parent Product's Party Policy Providing a human-readable name for this party category <code>minCount</code> Number The minimum number of party members/equipment that must be included in a booking for this category Derived from parent Product's Party Policy Enforcing the minimum count for this party category in bookings <code>maxCount</code> Number The maximum number of party members/equipment that can be included in a booking for this category Derived from parent Product's Party Policy Enforcing the maximum count for this party category in bookings"},{"location":"datatypes/policies/party-policies/#partycategories-and-partycompositionrules","title":"<code>partyCategories</code> and <code>partyCompositionRules</code>","text":"<pre><code>flowchart LR\na[Visitor attempts to make a booking] ---&gt; b[`partyCategories` define the allowed party member/equipment types and min/max values] --&gt; c[Visitor provides party member/equipment information]\nc --&gt; d{Does the provided party composition comply with every `partyCategories` rule?}\nd -- No --&gt; e[Booking is rejected due to invalid party composition]\nd -- Yes --&gt; f{Does the provided party composition comply with every `partyCompositionRules` rule?}\nf -- No --&gt; g[Booking is rejected due to invalid party composition]\nf -- Yes --&gt; h[Booking is accepted]\n</code></pre>"},{"location":"datatypes/policies/policies-overview/","title":"Policies","text":"<p>Policies define the rules that govern how reservations behave across the entire system.</p> <p>They describe: - when users can make reservations - how users can modify or cancel existing reservations - who can participate in the experience they are reserving - what they will be charged for the experience</p> <p>Policies are reusable, versioned ruleset templates that allow administrators to create new Products and ProductDates with preconfigured governance rules.</p>"},{"location":"datatypes/policies/policies-overview/#shared-policy-concepts","title":"Shared Policy Concepts","text":"<p>Every policy has: - a policy type (reservation, change, party, fee) - a policyId (the logical identifier) - a policyIdVersion (the version number) - a displayName and description - metadata such as creation and update timestamps</p> <p>This ensures policies are easy to reference, audit, and evolve.</p> <p>Policies are never edited in place. Instead: - A new version is created when rules change. - Products can preconfigured to always use the latest policy version, or lock in a specific version. - Existing bookings retain the old version.</p> <p>This protects users from retroactive rule changes and provides a clear audit trail.</p> <p>All policy types share a common evaluation pattern: - Time based rules can be anchored to fixed times or can be dependent on anchors defined at reservation time, like user-selected arrival and depature dates - Time\u2011based rules anchor to local park time, not UTC. - All calculations - time-based, money-based, or otherwise, must be deterministic. - All rules are denormalized/resolved before runtime evaluation.</p>"},{"location":"datatypes/policies/policies-overview/#policy-primitives","title":"Policy Primitives","text":"<p>Policies are comprised of primitives to break down complex rulesets into more simple, deterministic building blocks. View primitives here.</p>"},{"location":"datatypes/policies/policy-primitives/","title":"Policy Primitives","text":"<p>Policy primitives are the fundamental building blocks used to define all reservation governance in the system. While the system exposes high-level policy types, each of these types is ultimately composed from a shared set of primitives. These primitives provide consistent vocabulary for expressing rules, ensure predictable, deterministic behaviour across products, and make the policy layer extensible as new reservation models are introduced.</p> <p>Understanding these primitives is essential for understanding how policies work, how overrides behave, and how ProductDates are generated.</p> <p>All policies are composed from these primitives: - Temporal Anchor Primitive \u2014 define what point in time rules are relative to - Temporal Duration Primitive \u2014 define how long something must or may last - Temporal Window Primitive \u2014 define when an action is allowed - Interval Primitive \u2014 define groups of dates that behave as a unit - Arithmetic Primitive \u2014 A linear arithmetic expression that determines numerical results, evaluated left-to-right - Comparison Primitive - Compares two arithmetic primitives using a comparison operator - Eligibility Primitive \u2014 Uses comparison primitives to chain boolean results and drive if/then logic - Reference Primitive - a named, pre-computed or derived value that is evaluated once and stored in booking context so other primitives can reference it</p> <p>Each primitive is small and self\u2011contained, but together they can express the full complexity of reservation governance.</p>"},{"location":"datatypes/policies/policy-primitives/#temporal-anchor-primitive","title":"Temporal Anchor Primitive","text":"<p>The date or timestamp that temporal calculations can use as reference points.</p> <p>Examples: - Arrival Date - Departure Date - Reservation Date - Fixed calendar datetimes (e.g., \u201cJan 17 at 08:00\u201d)</p> <p>Anchors should resolve to either a calendar date (YYYY-MM-DD) or a single ISO 8601 timestamp (when supplied a time-of-day offset and  combined with the appropriate timezone). They ensure that booking windows, change windows, and fee calculations behave consistently\u2014even across daylight savings transitions.</p>"},{"location":"datatypes/policies/policy-primitives/#evaluation-procedure","title":"Evaluation procedure","text":"<ol> <li>Resolve the initial calendar date</li> </ol> <p>The anchor begins by looking at the <code>anchorRef</code> property. This must reference a temporal anchor from the <code>refStore</code>. The <code>anchorRef</code> resolves to a calendar date. If the reference is a timestamp, the calendar date is chopped from the timestamp:</p> <p><code>2026-01-27T14:58:03-08:00</code> becomes 2026-01-27</p> <p>If <code>anchorRef</code> cannot be resolved because the value in <code>refStore</code> does not exist, the resolution is skipped (see reference primitive dependency loops).</p> <p>If there are no other fields in the anchor, the anchor is resolved as a calendar date and stored.</p> <ol> <li>Apply the duration in the temporal direction</li> </ol> <p>If the anchor contains a <code>duration</code> and a <code>direction</code>, apply the duration to the <code>initialDate</code> in the temporal direction of <code>direction</code>. The result is a calendar date.</p> <p>If there is no <code>timeOfDay</code> field in the anchor, the anchor is resolved as calendar date and stored.</p> <ol> <li>Apply time of day offset</li> </ol> <p>If the anchor contains a <code>timeOfDay</code> field, apply the time of day offset to the running calculated date (this may be from step 1, or step 2 if there was a duration applied).The result is an ISO 8601 timestamp, with the timezone set to whatever the policy's <code>timezone</code> is.</p> <p>The anchor is resolved as an ISO 8601 timestamp and stored.</p> <p>The order of operations is important when calculating temporal windows, so as to make the result deterministic.</p> <p>This order is crucial to avoid temporal nondeterminism: - Applying time-of-day calculation before duration math can cause the result to shift by 1 hour over daylight savings transitions. - Performing duration math in UTC may not respect daylight savings transitions in certain timezones. - All calculations must occur in the same timezone.</p> <pre><code>flowchart TB\na[Look up `anchorRef` value] --&gt; b{does `anchorRef` exist?}\nb -- No --&gt; c[Skip resolution of this anchor, and any primitives depending on it]\nb -- Yes --&gt; d{Is `anchorRef` a timestamp?}\nd -- Yes --&gt; e[Chop to calendar date] --&gt; f\nd -- No --&gt; f{Is there a `duration` to apply?}\nf -- Yes --&gt; g[Apply duration in the specified `direction`] --&gt; h\nf -- No --&gt; h{Is there a `timeOfDay` offset to apply?}\nh -- Yes --&gt; i[Apply time-of-day offset] --&gt; j\nh -- No --&gt; j[Anchor resolution complete]\n</code></pre>"},{"location":"datatypes/policies/policy-primitives/#temporal-anchor","title":"Temporal Anchor","text":"Property Type Description \u00a0 <code>anchorRef</code> String The id of the reference point used for time calculations. Determines how windows and durations are interpreted. <code>useAnchorTime</code> Boolean If true, chop <code>anchorRef</code> time of day before evaluation, and reapply after. Defaults to '00:00:00' <code>duration</code> TemporalDuration The duration to apply to the <code>initialDate</code> to get <code>initialDateTime</code> <code>timeOfDay</code> Time Time-of-day offset applied to the calendar date to get a  timestamp. Overrides <code>useAnchorTime</code>"},{"location":"datatypes/policies/policy-primitives/#time","title":"Time","text":"<pre><code>TimeOfDay = {\n  \"hour\": number,      // hour of day (0-23)\n  \"minute?:\" number,   // minute of hour (0-59)\n  \"second?:\" number    // second of minute (0-59)\n}\n</code></pre> <pre><code>// Below are some possible ReferencePrimitive points for `anchorRrf`.\nTemporalAnchorEnum: {\n   \"anchors.arrivalDate\",         // The date of visitor arrival\n   \"anchors.departureDate\",       // The date of visitor departure\n   \"anchors.reservationDate\",     // The date the reservation is made\n   \"anchors.rangeStart\",          // Product's `rangeStart` value\n   \"anchors.rangeEnd\",            // Product's `rangeEnd` value\n}\n</code></pre> <p>Example: <pre><code>\"temporalAnchor\": {\n   \"anchorRef\": \"anchors.arrivalDate\",\n   \"timeOfDay\": {\n      \"hour\": 7\n   }\n}\n</code></pre></p>"},{"location":"datatypes/policies/policy-primitives/#temporal-duration-primitive","title":"Temporal Duration Primitive","text":"<p>The length of time of an event.</p> <p>Examples: - Minimum/maximum stay length - Length of a rolling reservation window (4 months in advance, two days in advance) - Minimum notice before arrival - Penalty windows (\u201cchanges within 48 hours incur a fee\u201d)</p> <p>Duration rules allow the system to express constraints that depend on how long something lasts, not just when it occurs.</p> <p>Schema <pre><code>TemporalDuration {\n  direction: string  // \"before | after\"\n  // At least one field must be present.\n  years?: number;    // integer \u2265 0\n  months?: number;   // integer \u2265 0\n  weeks?: number;    // integer \u2265 0\n  days?: number;     // integer \u2265 0\n  hours?: number;    // integer \u2265 0\n  minutes?: number;  // integer \u2265 0\n  seconds?: number;  // integer \u2265 0\n}\n</code></pre> - All fields are optional, but at least one must be provided (<code>direction</code> exempt). - All values must be non\u2011negative integers. - Durations are not normalized (e.g., { months: 4 } stays as 4 months, not 120 days).</p> <p>Example: <pre><code>\"temporalDuration\": {\n  \"months\": 4\n}\n</code></pre></p>"},{"location":"datatypes/policies/policy-primitives/#temporal-window-primitive","title":"Temporal Window Primitive","text":"<p>When an action is allowed or disallowed. They are typically comprised of a pair of temporal anchor primitives, one for 'open', the other for 'close'.</p> <p>Examples: - When reservations open and close - When changes/cancellations are permitted - When peak pricing or discounts apply</p> <p>Window rules give the system deterministic control over time\u2011bounded actions.</p> <pre><code>TemporalWindow {\n  id: String                 // Identifier\n  label: String              // Human-readable label\n  open: TemporalAnchor;      // opening time boundary\n  close: TemporalAnchor;     // closing time boundary\n}\n</code></pre> <p>Example: This TemporalWindow describes a time block from 7am on the day four months before the arrival date, to 11:59pm on the arrival date itself. <pre><code>\"temporalWindow\": [\n  \"id\": \"discoverabilityWindow\",\n  \"label\": \"Discoverability Window\",\n  \"open\": {\n    \"anchorRef\": \"arrivalDate\",\n    \"duration\": { \"months\": 4, \"direction\": \"before\" },\n    \"timeOfDay\": { \"hour\": 7 }\n  },\n  \"close\": {\n    \"anchorRef\": \"arrivalDate\",\n    \"timeOfDay\": { \"hour\": 23, \"minute\": 59 }\n  }\n}\n</code></pre></p>"},{"location":"datatypes/policies/policy-primitives/#interval-primitive","title":"Interval Primitive","text":"<p>Groups of dates that behave as a unit.</p> <p>Examples: - Holiday weekend minimum\u2011stay requirements</p> <p>Intervals allow the system to express rules like \u201cif you book any date in this block, you must book all days in the block.\u201d</p> <p>Note that similar rules like \"minimum 3 nights stay\" can be stored as <code>minStay</code> in a booking policy, and do not necessarily enforce the same intent. A <code>minStay</code> of 3 on long weekend nights does not force visitors to book specific days, only that their stay must be at least 3 days long.</p> <p>Schema: <pre><code>Interval {\n  label: string                // Label of the interval (identifying what it applies to)\n  description: string          // Description of the interval (describing what it applies to)\n  dates: LocalDate[];          // required \u2014 list of ISO dates (YYYY-MM-DD)\n}\n</code></pre> Example: Special event pricing applies only if the entire stay covers July 1\u20133. <pre><code>\"interval\": {\n  \"dates\": [\n    \"2025-07-01\",\n    \"2025-07-02\",\n    \"2025-07-03\"\n  ],\n  \"requireAllDates\": true\n}\n</code></pre></p>"},{"location":"datatypes/policies/policy-primitives/#arithmetic-primitive","title":"Arithmetic Primitive","text":"<p>A linear sequence of numerical operands and operators evaluated left-to-right. They are structured as array with an odd number of indices. Each odd numbered index is an operand and each even-numbered index is an operator. Starting from the first operand, each pair of following <code>[operator, operand]</code> is applied in order until the array has been traversed, resolving in a final number.</p>"},{"location":"datatypes/policies/policy-primitives/#operand","title":"Operand","text":"<p>An operand may be a constant numerical value, or a value taken from <code>evaluationContext</code> that resolves to a number, or a nested ArithmeticPrimitive expression that resolves to number.</p> Property Type Description <code>type</code> String <code>constant</code>, <code>field</code>, <code>expression</code> <code>value</code> Any A constant numerical value, or the name of the field to resolve, or another ArithmeticPrimitive"},{"location":"datatypes/policies/policy-primitives/#arithmetic-operator","title":"Arithmetic Operator","text":"<pre><code>ArithmeticOperators = [\n  add,                     // add\n  sub,                     // subtract\n  mul,                     // multiply\n  div,                     // divide\n]\n</code></pre> <pre><code>number = [ operand, operator, operand, operator, operand, ...]\n</code></pre>"},{"location":"datatypes/policies/policy-primitives/#comparison-primitive","title":"Comparison Primitive","text":"<p>A comparator that compares two arithmetic primitives. It is comprised of a left-hand-side operand, a comparison operator, and a right-hand-side operand. Evalutates to a boolean.</p>"},{"location":"datatypes/policies/policy-primitives/#comparison","title":"Comparison","text":"Property Type Description <code>lhs</code> ArithmeticPrimitive An arithmetic primitive <code>op</code> ComparisonOperator A comparison operator <code>rhs</code> ArithmeticPrimitive An arithmetic primitive"},{"location":"datatypes/policies/policy-primitives/#comparison-operator","title":"Comparison Operator","text":"<pre><code>comparisonOperators = [\n \"eq\",             // equal\n \"neq\",            // not equal\n \"lt\",             // less than\n \"lte\",            // less than or equal\n \"gt\",             // greater than\n \"gte\",            // greater than or equal\n]\n</code></pre>"},{"location":"datatypes/policies/policy-primitives/#eligibility-primitive","title":"Eligibility Primitive","text":"<p>A simple conditional structure comprised of comparison primitives. It contains an <code>if</code> statement and a <code>then</code> statement. Evaluates to a boolean.</p> <p>Eligibility primitives support the following logical evaluation:</p> <p>if X is TRUE, then Y MUST also be TRUE, else the evaluation fails and the expression is FALSE. if X is FALSE, then the expression is never evaluated.</p>"},{"location":"datatypes/policies/policy-primitives/#eligibility","title":"Eligibility","text":"Property Type Description <code>id</code> String Expression identifier <code>label</code> String Human readable label of the expression <code>failMsg</code> String A helpful message to display in the event the expression fails <code>if</code> [ComparisonPrimitive] An array of comparison primitives <code>then</code> [ComparisonPrimitive] An array of comparison primitives"},{"location":"datatypes/policies/policy-primitives/#if-statement","title":"If Statement","text":"<p>A logical statement comprised of an array of comparison primitives and chained by a logical AND. Every comparison primitive must evaluate to TRUE for the if statement to pass and the <code>then</code> statement to be evaluated. An empty array automatically evaluates to TRUE.</p>"},{"location":"datatypes/policies/policy-primitives/#then-statement","title":"Then Statement","text":"<p>A logical statement comprised of an array of comparison primitives and chained by a logical AND. Every comparison primitive must evaluate to TRUE for the then statement to pass and for the eligibility primitive to resolve to TRUE.</p>"},{"location":"datatypes/policies/policy-primitives/#reference-primitive","title":"Reference Primitive","text":"<p>A reference primitive is a lightweight lookup that retrieves the value of a previously defined fact from the evaluation context so other primitives can use it without recomputing anything.</p>"},{"location":"datatypes/policies/policy-primitives/#reference","title":"Reference","text":"Property Type Description <code>id</code> String Reference identifier <code>label</code> String Human readable label of the reference <code>type</code> String Reference data type <code>value</code> Any The value of the reference <p>During booking evaluation, reference primitives are recorded in a lookup store called <code>refStore</code>. This way, they can be made available for other primitives, even across policies, so the whole booking maintains the same context.</p> <p>The <code>refStore</code> is populated in the order that references are made available. Some are directly available at the beginning of a booking evaluation stage, others are derived/evaluated and available at the end of that stage. Each stage should have access to the references resolved in the preceding stages. The approximate ordering of stages follows:</p> <ol> <li>User refs: information related to the user making the booking</li> <li>Inventory: information related to the inventory the user has selected for the booking</li> <li>Anchors: temporal anchors that are inherently defined by the inventory selected (<code>arrivalDate</code>, <code>departureDate</code>, etc)</li> <li>Windows: temporal windows that are derived from the previously calculated anchors.</li> <li>Dependency Loop: Some temporal anchors &amp; windows are derived from others. This stage loops through unresolved windows and anchors and resolves dependent ones. The looping stops when all dependencies have been resolved, or nothing new is evaluated during the loop.</li> <li>PartyCategories: Counts of people and equipment classes defined by the party policy and provided by the user when they declare their party breakdown</li> <li>PartyGroups: Aggregates of party counts defined by the party policy</li> <li>Fees: Fee schedule defined in the fee policy</li> </ol>"},{"location":"datatypes/policies/policy-primitives/#refstore","title":"RefStore","text":"Property Type Description <code>user</code> [ReferencePrimitive] Reference primitives related to the user making the booking <code>inventory</code> [ReferencePrimitive] Reference primitives related to the booking inventory <code>anchors</code> [ReferencePrimitive] Reference primitives that are temporal anchors (ISO 8601 timestamps) <code>windows</code> [ReferencePrimitive] Reference primitives that are temporal windows (contain open and close ISO 8601 timestamps) <code>partyCategories</code> [ReferencePrimitive] Reference primitives that are first-order party breakdown classes (people AND equipment) <code>partyGroups</code> [ReferencePrimitive] Reference primitives that are second-order party aggregations (groups of <code>partyCategories</code>) <code>fees</code> [ReferencePrimitive] Reference primitives that are fees"},{"location":"datatypes/policies/policy-primitives/#how-primitives-compose-into-policy-schemas","title":"How Primitives Compose into Policy Schemas","text":"<p>Policy primitives are the foundational building blocks of the reservation governance model. Each primitive represents a small, focused concept\u2014such as a time window, a duration constraint, or an eligibility requirement. Policy types (Booking, Change, Party, Fee) are not independent inventions; they are compositions of these primitives arranged to express the rules relevant to each domain.</p>"},{"location":"datatypes/policies/reservation-policies/","title":"Reservation Policy","text":"property type description derived from evaluated when <code>pk</code> String Partition key \"policy::\\::\\\" Searching all versions of this policy <code>sk</code> String Sort key \"v\\\" OR \"latest\" Searching for a specific version of this policy <code>gsipk</code> String Global secondary index partition key Reserved Reserved <code>gsisk</code> String Global secondary index sort key Reserved Reserved <code>schema</code> String Data type/Schema \"policy\" Identifying that this item is a \"policy\" <code>globalId</code> String Globally unique UUID Automatically generating on policy creation Searching for this specific item using the <code>globalId</code> GSI <code>policyType</code> String The type of policy \"reservation\" Searching for all policies of this type <code>policyId</code> String A unique identifier for this policy, specific to the policy type Automatically generating on policy creation Searching for all versions of this specific policy <code>policyIdVersion</code> Number The version number of this policy Automatically incrementing on policy update Searching for a specific version of this policy <code>isLatest</code> Boolean Whether this is the latest version of the policy Automatically setting on policy update Searching for the latest version of this policy <code>displayName</code> String A human-readable name for this policy Provided on policy creation and update Displaying this policy in a user interface <code>description</code> String A human-readable description of this policy Provided on policy creation and update Displaying this policy in a user interface <code>refStore</code> ReferenceStore The reference store that contains any additional data needed to evaluate this policy Provided on policy creation and update Accessing additional data needed to evaluate this policy <code>productRules</code> ReservationProductRules The rules that govern how this policy is applied at the Product level Provided on policy creation and update Evaluating whether a Product complies with the rules defined in this policy <code>productDateRules</code> ReservationProductDateRules The rules that govern how this policy is applied at the ProductDate level Provided on policy creation and update Evaluating whether a ProductDate complies with the rules defined in this policy <code>createdAt</code> Timestamp The timestamp when this policy was created Automatically setting on policy creation Tracking when this policy was created <code>lastUpdated</code> Timestamp The timestamp when this policy was last updated Automatically updating on policy update Tracking when this policy was last updated"},{"location":"datatypes/policies/reservation-policies/#referencestore","title":"ReferenceStore","text":"property type description derived from evaluated when <code>user</code> [ReferencePrimitive] Reference primitives related to the user User making the reservation Evaluating policies that depend on user attributes <code>inventory</code> [ReferencePrimitive] Reference primitives related to inventory Inventory being reserved Evaluating policies that depend on inventory attributes <code>temporalAnchors</code> [ReferencePrimitive] Reference primitives related to temporal anchors (e.g., current date) Current date and time Evaluating policies that depend on temporal conditions <code>temporalWindows</code> [ReferencePrimitive] Reference primitives related to temporal windows (e.g., discovery window, reservation window) Current date and time, Product/ProducDate temporal window definitions Evaluating policies that depend on whether the current date falls within certain temporal windows <code>partyCategories</code> [ReferencePrimitive] Reference primitives related to party categories (e.g., adult, child, senior) Composition of the party included in the reservation Evaluating policies that depend on the composition of the party making the reservation"},{"location":"datatypes/policies/reservation-policies/#reservationproductrules","title":"ReservationProductRules","text":"<p>These rules are scoped to entire Products/Bookings and are independent of when reservations occur. They answer the question: \"What policies govern reservations of this offering, regardless of when they occur?\"</p> <p>These will be fully resolved on the Product.</p> <p>Some policies may be abstract enough to be grouped into reusable modules across Products, while others may be specific enough to be defined singularly and exclusively to the Product. Reservation Policies aim to capture the former.</p> property type description derived from evaluated when <code>isDiscoverable</code> Boolean Is the Product discoverable? If yes, it can be returned in search results. If no, it will not be returned in search results. Provided on policy creation and update Evaluating whether a Product is discoverable based on this policy <code>isReservable</code> Boolean Is the Product reservable? If yes, ProductDates can be queried. If no, it ProductDates cannot be queried and no reservations can be made. Provided on policy creation and update Evaluating whether a Product is reservable based on this policy <code>minTotalDays</code> Number What is the minimum total number of days that must be included in a reservation of this Product? Provided on policy creation and update Evaluating whether a reservation meets the minimum total days requirement based on this policy <code>maxTotalDays</code> Number What is the maximum total number of days that can be included in a reservation of this Product? Provided on policy creation and update Evaluating whether a reservation meets the maximum total days requirement based on this policy <code>holdDuration</code> Duration How long can a reservation of this Product be held before it expires? Provided on policy creation and update Evaluating whether a reservation hold has expired based on this policy <code>availabilityEstimationPattern</code> AvailabilityEstimationPattern What pattern governs how availability is estimated for ProductDates related to this Product? Provided on policy creation and update Determining how availability is estimated for ProductDates related to this Product based on this policy <code>temporalWindows</code> ProductTemporalWindows The temporal windows that govern when this Product is discoverable and reservable Provided on policy creation and update Evaluating whether a Product is discoverable and reservable based on the current date and the temporal windows defined in this policy"},{"location":"datatypes/policies/reservation-policies/#availabilityestimationpattern","title":"AvailabilityEstimationPattern","text":"<p>An AvailabilityEstimationPattern defines the pattern used to estimate availability for ProductDates related to a Product. This pattern helps in providing an eventually-consistent estimate of availability for booking on each date.</p> <p>ProductDates are high-traffic items that are read-optimized. To keep an accurate availability count on each ProductDate would require a write operation on every booking, which could lead to performance issues. Instead, the system uses an eventually-consistent approach to availability estimation, where availability is estimated based on a defined pattern and updated on a regular cadence.</p> <p>Each ProductDate generates a tiny, cheap, high-frequency AvailabilitySignal item. When availability for that date is affected, the AvailabilitySignal makes note. Then, on a cadence defined by AvailabilityEstimationPattern, a cronjob process will read the AvailabilitySignal, and if a change has occured perform a more rigorous availability estimate. This allows the system to provide a reasonably up-to-date estimate of availability without needing to perform expensive write operations on the ProductDate for every booking. Additionally, the estimation check does not occur if the AvailabilitySignal has not changed since the last estimate, which helps to further reduce unnecessary processing during periods of low traffic.</p> <p>If <code>estimationMode</code> is set to \"exact\", the system will provide a count of available items on the cadence increment. If <code>estimationMode</code> is set to \"tiered\", the system will provide a tier of availability (e.g., \"high\", \"medium\", \"low\") based on thresholds defined in the AvailabilityEstimationPattern.</p> property type description derived from evaluated when <code>estimationMode</code> String The mode of availability estimation (e.g., \"exact\", \"tiered\") Administrators on Product PUT/POST Determining the mode of availability estimation for ProductDates related to this Product <code>cadence</code> CadenceBucket The frequency at which availability estimation should occur (e.g., every 5 minutes) Administrators on Product PUT/POST Determining how often availability estimation should occur for ProductDates related to this Product <code>tiers?</code> AvailabilityTier Optional ordered array of availability tiers with thresholds, used if <code>estimationMode</code> is set to \"tiered\" Administrators on Product PUT/POST Defining the availability tiers and their corresponding thresholds for tiered availability estimation"},{"location":"datatypes/policies/reservation-policies/#cadencebucket","title":"CadenceBucket","text":"<p>A CadenceBucket defines the frequency at which availability estimation should occur for ProductDates related to a Product. The system will trigger availability estimation checks on the associated ProductDates at intervals defined by the CadenceBucket. Each CadenceBucket corresponds to an AWS EventBridge rule that triggers the availability estimation process on the defined cadence. For example, if a Product has a cadence of \"5min\", the system will perform availability estimation checks for its ProductDates every 5 minutes. All Products of the same CadenceBucket can be processed in a single batch job triggered by the corresponding EventBridge rule, allowing for efficient handling of availability estimation across multiple Products.</p> property type description derived from evaluated when <code>id</code> String Unique identifier for the cadence bucket Administrators on Product PUT/POST Distinguishing this cadence bucket from others in the same estimation pattern <code>label</code> String The label for this cadence bucket (e.g., \"5min\", \"15min\", \"30min\") Administrators on Product PUT/POST Providing a human-readable label for this cadence bucket"},{"location":"datatypes/policies/reservation-policies/#availabilitytier","title":"AvailabilityTier","text":"property type description derived from evaluated when <code>id</code> String Unique identifier for the availability tier Administrators on Product PUT/POST Distinguishing this availability tier from others in the same estimation pattern <code>label</code> String The label for this availability tier (e.g., \"high\", \"medium\", \"low\") Administrators on Product PUT/POST Providing a human-readable label for this availability tier <code>maxPercentage</code> Number The maximum percentage of availability for this tier (e.g., 0.7 for 70%) Administrators on Product PUT/POST Determining the upper threshold of availability for this tier in tiered availability estimation"},{"location":"datatypes/policies/reservation-policies/#product-level-isdiscoverable-and-discoverywindow","title":"Product level <code>isDiscoverable</code> and <code>discoveryWindow</code>","text":"<pre><code>flowchart LR\n\na[Visitor searches for Products] --&gt; b{Product has `isDiscoverable` set to true?}\nb -- Yes --&gt; c{Query time is within `discoveryWindow`?}\nb -- No --&gt; d[Product is not returned in search results]\nc -- Yes --&gt; e[Product is returned in search results]\nc -- No --&gt; d[Product is not returned in search results]\n</code></pre>"},{"location":"datatypes/policies/reservation-policies/#product-level-isreservable","title":"Product level <code>isReservable</code>","text":"<pre><code>flowchart LR\n\na[Visitor sees list of Discoverable Products] --&gt; e[User selects a Product to view details]\ne --&gt; b{Product has `isReservable` set to true?}\nb -- Yes --&gt; c[Visitor can query ProductDates and make reservations for this Product]\nb -- No --&gt; d[Visitor cannot query ProductDates or make reservations for this Product]\n</code></pre>"},{"location":"datatypes/policies/reservation-policies/#mintotaldays-and-maxtotaldays","title":"<code>minTotalDays</code> and <code>maxTotalDays</code>","text":"<pre><code>flowchart LR\na[Visitor attempts to make a reservation for a Product] --&gt; b{Total days in reservation &gt;= `minTotalDays`?}\nb -- No --&gt; c[Reservation is rejected]\nb -- Yes --&gt; d{Total days in reservation &lt;= `maxTotalDays`?}\nd -- No --&gt; c[Reservation is rejected]\nd -- Yes --&gt; e[Reservation process continues]\n</code></pre>"},{"location":"datatypes/policies/reservation-policies/#producttemporalwindows","title":"ProductTemporalWindows","text":"<p>Below are the mandatory temporal windows that must be defined for a reservation policy. Additional temporal windows can be added as needed.</p> property type description derived from evaluated when <code>discoveryWindow</code> TemporalWindow If the Product is discoverable, what is the temporal window for which it should be discoverable? Provided on policy creation and update Evaluating whether a Product is discoverable based on the current date and the discovery window defined in this policy"},{"location":"datatypes/policies/reservation-policies/#reservationproductdaterules","title":"ReservationProductDateRules","text":"<p>These rules are scoped to ProductDates/BookingDates and can change day-to-day. They answer the question: \"What policies that govern reservations of this offering depend on when when a particular action occur?\"</p> property type description derived from evaluated when <code>isDiscoverable</code> Boolean Is the ProductDate discoverable? If yes, it can be returned in search results. If no, it will not be returned in search results. Provided on policy creation and update Evaluating whether a ProductDate is discoverable based on this policy <code>isReservable</code> Boolean Is the ProductDate reservable? If yes, reservations can be made for that date. If no, reservations cannot be made for that date. Provided on policy creation and update Evaluating whether a ProductDate is reservable based on this policy <code>minDailyInventory</code> Number What is the minimum Inventory quanitity that Bookings must reserve for this ProductDate? Provided on policy creation and update Evaluating whether a reservation meets the minimum daily inventory requirement based on this policy <code>maxDailyInventory</code> Number What is the maximum Inventory quanitity that can be reserved for this ProductDate? Provided on policy creation and update Evaluating whether a reservation meets the maximum daily inventory requirement based on this policy <code>temporalWindows</code> ProductDateTemporalWindows The temporal windows that govern when this ProductDate is discoverable and reservable Provided on policy creation and update Evaluating whether a ProductDate is discoverable and reservable based on the current date and the temporal windows defined in this policy"},{"location":"datatypes/policies/reservation-policies/#productdate-level-isdiscoverable-and-discoverywindow","title":"ProductDate level <code>isDiscoverable</code> and <code>discoveryWindow</code>","text":"<pre><code>flowchart LR\na[Visitor selects a Product to view details] --&gt; b[System queries ProductDates for the selected Product]\nb --&gt; c{ProductDate has `isDiscoverable` set to true?}\nc -- Yes --&gt; d{Query time is within `discoveryWindow`?}\nc -- No --&gt; e[ProductDate is not returned in search results]\nd -- Yes --&gt; f[ProductDate is returned in search results]\nd -- No --&gt; e[ProductDate is not returned in search results]\n</code></pre>"},{"location":"datatypes/policies/reservation-policies/#productdate-level-isreservable-and-reservationwindow","title":"ProductDate level <code>isReservable</code> and <code>reservationWindow</code>","text":"<pre><code>flowchart LR\na[Visitor sees list of Discoverable ProductDates for a Product] --&gt; b{ProductDate has `isReservable` set to true?}\nb -- Yes --&gt; c{Query time is within `reservationWindow`?}\nb -- No --&gt; d[ProductDate cannot be reserved]\nc -- Yes --&gt; e[ProductDate can be reserved]\nc -- No --&gt; d[ProductDate cannot be reserved]\n</code></pre>"},{"location":"datatypes/policies/reservation-policies/#mindailyinventory-and-maxdailyinventory","title":"<code>minDailyInventory</code> and <code>maxDailyInventory</code>","text":"<pre><code>flowchart LR\na[Visitor attempts to make a reservation for a ProductDate] --&gt; b{Daily inventory in reservation &gt;= `minDailyInventory`?}\nb -- No --&gt; c[Reservation is rejected]\nb -- Yes --&gt; d{Daily inventory in reservation &lt;= `maxDailyInventory`?}\nd -- No --&gt; c[Reservation is rejected]\nd -- Yes --&gt; e[Reservation process continues]\n</code></pre>"},{"location":"datatypes/policies/reservation-policies/#productdatetemporalwindows","title":"ProductDateTemporalWindows","text":"<p>Below are the mandatory temporal windows that must be defined for a reservation policy. Additional temporal windows can be added as needed.</p> property type description derived from evaluated when <code>discoveryWindow</code> TemporalWindow If the ProductDate is discoverable, what is the temporal window for which it should be discoverable? Provided on policy creation and update Evaluating whether a ProductDate is discoverable based on the current date and the discovery window defined in this policy <code>reservationWindow</code> TemporalWindow What is the temporal window for which reservations can be made for this ProductDate? Provided on policy creation and update Evaluating whether reservations can be made for this ProductDate based on the current date and the reservation window defined in this policy <code>restrictedBookingWindow</code> TemporalWindow What is the temporal window for which bookings of this ProductDate are final-sale? Provided on policy creation and update Evaluating whether bookings of this ProductDate are final-sale based on the current date and the restricted booking window defined in this policy"},{"location":"datatypes/policies/reservation-policies/#restrictedbookingwindow","title":"<code>restrictedBookingWindow</code>","text":"<pre><code>flowchart LR\na[Visitor attempts to make a reservation for a ProductDate] --&gt; b{Current date is within `restrictedBookingWindow`?}\nb -- Yes --&gt; c[Booking is final-sale and cannot be cancelled or modified]\nb -- No --&gt; d[Booking can be cancelled or modified according to standard policies]\n</code></pre>"},{"location":"features/qr-code/","title":"QR Codes","text":""},{"location":"features/qr-code/#qr-code-verification","title":"QR Code Verification","text":"<p>QR codes are automatically generated for confirmed bookings to enable park staff verification at entry points.</p>"},{"location":"features/qr-code/#booking-response-with-qr-code","title":"Booking Response with QR Code","text":"<p>When retrieving a confirmed booking via <code>GET /bookings/{bookingId}</code>, the response includes: <pre><code>{\n  \"bookingId\": \"abc123-...\",\n  \"bookingStatus\": \"confirmed\",\n  ...\n  \"qrCode\": {\n    \"dataUrl\": \"data:image/png;base64,iVBORw0KG...\",\n    \"verificationUrl\": \"https://reserve-rec.bcparks.ca/verify/{bookingId}/{hash}\"\n  }\n}\n</code></pre> Fields: - <code>dataUrl</code>: Base64-encoded PNG image (300x300px) for display/printing - <code>verificationUrl</code>: Admin-facing URL containing booking ID and HMAC signature Note: QR codes are only generated for bookings with <code>bookingStatus: \"confirmed\"</code>. Cancelled, pending, or expired bookings return <code>qrCode: null</code>.</p>"},{"location":"features/qr-code/#verification-url-format","title":"Verification URL Format","text":"<p><pre><code>https://{domain}/verify/{bookingId}/{hash}\n</code></pre> - bookingId: UUID of the booking - hash: 16-character hexadecimal HMAC-SHA256 signature (prevents tampering)</p>"},{"location":"features/qr-code/#verification-response-admin-only","title":"Verification Response (Admin Only)","text":"<p>When an admin scans the QR code, the verification endpoint returns: <pre><code>{\n  \"valid\": true,\n  \"bookingId\": \"abc123-...\",\n  \"status\": \"confirmed\",\n  \"statusDetails\": {\n    \"isConfirmed\": true,\n    \"isCancelled\": false,\n    \"isExpired\": false,\n    \"isPending\": false\n  },\n  \"booking\": {\n    \"bookingId\": \"abc123-...\",\n    \"displayName\": \"Golden Ears Park - Backcountry Trail\",\n    \"startDate\": \"2025-06-15\",\n    \"endDate\": \"2025-06-17\",\n    \"guestName\": \"John Doe\",\n    \"partySize\": 4,\n    \"collectionId\": \"...\",\n    \"activityType\": \"backcountry\",\n    \"entryPoint\": \"...\",\n    \"exitPoint\": \"...\",\n    \"vehicleInformation\": {...}\n  },\n  \"verificationMetadata\": {\n    \"verifiedAt\": \"2025-06-15T10:30:00Z\",\n    \"verifiedBy\": \"admin-user-id\"\n  }\n}\n</code></pre> Security: Only minimal guest information (name, party size) is returned. Email, phone, address, and payment details are excluded to protect privacy.</p>"}]}